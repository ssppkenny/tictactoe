(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Vdom = require("./vdom.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tea_cmd = require("./tea_cmd.bs.js");
var Tea_sub = require("./tea_sub.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function programStateWrapper(initModel, pump, shutdown) {
  var model = {
    contents: initModel
  };
  var callbacks = {
    contents: {
      enqueue: (function (_msg) {
          console.log("INVALID enqueue CALL!");
        }),
      on: (function (param) {
          
        })
    }
  };
  var pumperInterface = Curry._1(pump, callbacks);
  var pending = {
    contents: undefined
  };
  var handler = function (msg) {
    var msgs = pending.contents;
    if (msgs !== undefined) {
      pending.contents = {
        hd: msg,
        tl: msgs
      };
      return ;
    }
    pending.contents = /* [] */0;
    var newModel = Curry._2(pumperInterface.handleMsg, model.contents, msg);
    model.contents = newModel;
    var msgs$1 = pending.contents;
    if (msgs$1 !== undefined) {
      if (msgs$1) {
        pending.contents = undefined;
        return List.iter(handler, List.rev(msgs$1));
      } else {
        pending.contents = undefined;
        return ;
      }
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "INVALID message queue state, should never be None during message processing!",
          Error: new Error()
        };
  };
  var renderEvents = {
    contents: /* [] */0
  };
  var finalizedCBs_enqueue = handler;
  var finalizedCBs_on = function (x) {
    if (typeof x === "number") {
      return List.iter(handler, renderEvents.contents);
    }
    if (x.TAG === /* AddRenderMsg */0) {
      renderEvents.contents = List.append(renderEvents.contents, {
            hd: x._0,
            tl: /* [] */0
          });
      return ;
    }
    var msg = x._0;
    renderEvents.contents = List.filter(function (mg) {
            return msg !== mg;
          })(renderEvents.contents);
  };
  var finalizedCBs = {
    enqueue: finalizedCBs_enqueue,
    on: finalizedCBs_on
  };
  callbacks.contents = finalizedCBs;
  var piRequestShutdown = function (param) {
    callbacks.contents = {
      enqueue: (function (_msg) {
          console.log("INVALID message enqueued when shut down");
        }),
      on: (function (param) {
          
        })
    };
    var cmd = Curry._1(shutdown, model.contents);
    Curry._1(pumperInterface.shutdown, cmd);
  };
  var renderString = function (param) {
    return Curry._1(pumperInterface.renderString, model.contents);
  };
  Curry._1(pumperInterface.startup, undefined);
  return {
          pushMsg: handler,
          shutdown: piRequestShutdown,
          getHtmlString: renderString
        };
}

function programLoop(update, view, subscriptions, initModel, initCmd, x) {
  if (x === undefined) {
    return function (callbacks) {
      var oldSub = {
        contents: /* NoSub */0
      };
      var handleSubscriptionChange = function (model) {
        var newSub = Curry._1(subscriptions, model);
        oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, newSub);
      };
      return {
              startup: (function (param) {
                  Tea_cmd.run(callbacks, initCmd);
                  handleSubscriptionChange(initModel);
                }),
              renderString: (function (model) {
                  return Vdom.renderToHtmlString(Curry._1(view, model));
                }),
              handleMsg: (function (model, msg) {
                  var match = Curry._2(update, model, msg);
                  var newModel = match[0];
                  Tea_cmd.run(callbacks, match[1]);
                  handleSubscriptionChange(newModel);
                  return newModel;
                }),
              shutdown: (function (cmd) {
                  Tea_cmd.run(callbacks, cmd);
                  oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, /* NoSub */0);
                })
            };
    };
  }
  var parentNode = Caml_option.valFromOption(x);
  return function (callbacks) {
    var priorRenderedVdom = {
      contents: /* [] */0
    };
    var latestModel = {
      contents: initModel
    };
    var noFrameID = -1;
    var nextFrameID = {
      contents: undefined
    };
    var doRender = function (_delta) {
      var _id = nextFrameID.contents;
      if (_id === undefined) {
        return ;
      }
      var newVdom_0 = Curry._1(view, latestModel.contents);
      var newVdom = {
        hd: newVdom_0,
        tl: /* [] */0
      };
      var justRenderedVdom = Vdom.patchVNodesIntoElement(callbacks, parentNode, priorRenderedVdom.contents, newVdom);
      priorRenderedVdom.contents = justRenderedVdom;
      Curry._1(callbacks.contents.on, /* Render */0);
      nextFrameID.contents = undefined;
    };
    var scheduleRender = function (param) {
      var match = nextFrameID.contents;
      if (match !== undefined) {
        return ;
      }
      var id = requestAnimationFrame(doRender);
      nextFrameID.contents = Caml_option.some(id);
    };
    var clearPnode = function (param) {
      while(parentNode.childNodes.length > 0) {
        var firstChild = parentNode.firstChild;
        if (!(firstChild == null)) {
          parentNode.removeChild(firstChild);
        }
        
      };
    };
    var oldSub = {
      contents: /* NoSub */0
    };
    var handleSubscriptionChange = function (model) {
      var newSub = Curry._1(subscriptions, model);
      oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, newSub);
    };
    var handlerStartup = function (param) {
      clearPnode(undefined);
      Tea_cmd.run(callbacks, initCmd);
      handleSubscriptionChange(latestModel.contents);
      nextFrameID.contents = noFrameID;
      doRender(16);
    };
    var renderString = function (model) {
      return Vdom.renderToHtmlString(Curry._1(view, model));
    };
    var handler = function (model, msg) {
      var match = Curry._2(update, model, msg);
      var newModel = match[0];
      latestModel.contents = newModel;
      Tea_cmd.run(callbacks, match[1]);
      scheduleRender(undefined);
      handleSubscriptionChange(newModel);
      return newModel;
    };
    var handlerShutdown = function (cmd) {
      nextFrameID.contents = undefined;
      Tea_cmd.run(callbacks, cmd);
      oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, /* NoSub */0);
      priorRenderedVdom.contents = /* [] */0;
      clearPnode(undefined);
    };
    return {
            startup: handlerStartup,
            renderString: renderString,
            handleMsg: handler,
            shutdown: handlerShutdown
          };
  };
}

function program(param, pnode, flags) {
  var match = Curry._1(param.init, flags);
  var initModel = match[0];
  var opnode = (pnode == null) ? undefined : Caml_option.some(pnode);
  var pumpInterface = programLoop(param.update, param.view, param.subscriptions, initModel, match[1], opnode);
  return programStateWrapper(initModel, pumpInterface, param.shutdown);
}

function standardProgram(param, pnode, args) {
  return program({
              init: param.init,
              update: param.update,
              view: param.view,
              subscriptions: param.subscriptions,
              shutdown: (function (_model) {
                  return /* NoCmd */0;
                })
            }, pnode, args);
}

function beginnerProgram(param, pnode, param$1) {
  var update = param.update;
  var model = param.model;
  return standardProgram({
              init: (function (param) {
                  return [
                          model,
                          /* NoCmd */0
                        ];
                }),
              update: (function (model, msg) {
                  return [
                          Curry._2(update, model, msg),
                          /* NoCmd */0
                        ];
                }),
              view: param.view,
              subscriptions: (function (_model) {
                  return /* NoSub */0;
                })
            }, pnode, undefined);
}

var map = Vdom.map;

exports.programStateWrapper = programStateWrapper;
exports.programLoop = programLoop;
exports.program = program;
exports.standardProgram = standardProgram;
exports.beginnerProgram = beginnerProgram;
exports.map = map;
/* Vdom Not a pure module */

},{"./tea_cmd.bs.js":2,"./tea_sub.bs.js":6,"./vdom.bs.js":7,"rescript/lib/js/caml_option.js":33,"rescript/lib/js/curry.js":37,"rescript/lib/js/list.js":43}],2:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Vdom = require("./vdom.bs.js");
var Curry = require("rescript/lib/js/curry.js");

function batch(cmds) {
  return {
          TAG: /* Batch */1,
          _0: cmds
        };
}

function call(call$1) {
  return {
          TAG: /* EnqueueCall */2,
          _0: call$1
        };
}

function fnMsg(fnMsg$1) {
  return {
          TAG: /* EnqueueCall */2,
          _0: (function (callbacks) {
              Curry._1(callbacks.contents.enqueue, Curry._1(fnMsg$1, undefined));
            })
        };
}

function msg(msg$1) {
  return {
          TAG: /* EnqueueCall */2,
          _0: (function (callbacks) {
              Curry._1(callbacks.contents.enqueue, msg$1);
            })
        };
}

function run(_callbacks, _x) {
  while(true) {
    var x = _x;
    var callbacks = _callbacks;
    if (typeof x === "number") {
      return ;
    }
    switch (x.TAG | 0) {
      case /* Mapper */0 :
          var subCallbacks = Curry._1(x._0, callbacks);
          _x = x._1;
          _callbacks = subCallbacks;
          continue ;
      case /* Batch */1 :
          return List.fold_left((function(callbacks){
                    return function (param, cmd) {
                      run(callbacks, cmd);
                    }
                    }(callbacks)), undefined, x._0);
      case /* EnqueueCall */2 :
          return Curry._1(x._0, callbacks);
      
    }
  };
}

function map(func, cmd) {
  var mapper = function (param) {
    return Vdom.wrapCallbacks(func, param);
  };
  return {
          TAG: /* Mapper */0,
          _0: mapper,
          _1: cmd
        };
}

var none = /* NoCmd */0;

exports.none = none;
exports.batch = batch;
exports.call = call;
exports.fnMsg = fnMsg;
exports.msg = msg;
exports.run = run;
exports.map = map;
/* Vdom Not a pure module */

},{"./vdom.bs.js":7,"rescript/lib/js/curry.js":37,"rescript/lib/js/list.js":43}],3:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Vdom = require("./vdom.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tea_json = require("./tea_json.bs.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Tea_result = require("./tea_result.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_string = require("rescript/lib/js/caml_string.js");
var Webapi__Dom__HtmlElement = require("rescript-webapi/src/Webapi/Dom/Webapi__Dom__HtmlElement.bs.js");

function text(str) {
  return {
          TAG: /* Text */1,
          _0: str
        };
}

function node(namespaceOpt, tagName, keyOpt, uniqueOpt, props, nodes) {
  var namespace = namespaceOpt !== undefined ? namespaceOpt : "";
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode(namespace, tagName, key, unique, props, nodes);
}

var lazy1 = Vdom.lazyGen;

function h1(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h1", key, unique, props, nodes);
}

function h2(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h2", key, unique, props, nodes);
}

function h3(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h3", key, unique, props, nodes);
}

function h4(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h4", key, unique, props, nodes);
}

function h5(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h5", key, unique, props, nodes);
}

function h6(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "h6", key, unique, props, nodes);
}

function div(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "div", key, unique, props, nodes);
}

function p(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "p", key, unique, props, nodes);
}

function hr(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "hr", key, unique, props, nodes);
}

function pre(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "pre", key, unique, props, nodes);
}

function blockquote(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "blockquote", key, unique, props, nodes);
}

function span(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "span", key, unique, props, nodes);
}

function a(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "a", key, unique, props, nodes);
}

function code(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "code", key, unique, props, nodes);
}

function em(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "em", key, unique, props, nodes);
}

function strong(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "strong", key, unique, props, nodes);
}

function i(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "i", key, unique, props, nodes);
}

function b(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "b", key, unique, props, nodes);
}

function u(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "u", key, unique, props, nodes);
}

function sub(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "sub", key, unique, props, nodes);
}

function sup(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "sup", key, unique, props, nodes);
}

function br(props) {
  return Vdom.fullnode("", "br", "br", "br", props, /* [] */0);
}

function br$p(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "br", key, unique, props, nodes);
}

function ol(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "ol", key, unique, props, nodes);
}

function ul(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "ul", key, unique, props, nodes);
}

function li(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "li", key, unique, props, nodes);
}

function dl(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "dl", key, unique, props, nodes);
}

function dt(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "dt", key, unique, props, nodes);
}

function dd(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "dd", key, unique, props, nodes);
}

function img(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "img", key, unique, props, nodes);
}

function iframe(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "iframe", key, unique, props, nodes);
}

function canvas(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "canvas", key, unique, props, nodes);
}

function math(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "math", key, unique, props, nodes);
}

function form(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "form", key, unique, props, nodes);
}

function input$p(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "input", key, unique, props, nodes);
}

function textarea(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "textarea", key, unique, props, nodes);
}

function button(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "button", key, unique, props, nodes);
}

function select(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "select", key, unique, props, nodes);
}

function option(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "option", key, unique, props, nodes);
}

function optgroup(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "optgroup", key, unique, props, nodes);
}

function label(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "label", key, unique, props, nodes);
}

function fieldset(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "fieldset", key, unique, props, nodes);
}

function legend(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "legend", key, unique, props, nodes);
}

function section(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "section", key, unique, props, nodes);
}

function nav(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "nav", key, unique, props, nodes);
}

function article(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "article", key, unique, props, nodes);
}

function aside(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "aside", key, unique, props, nodes);
}

function header(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "header", key, unique, props, nodes);
}

function footer(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "footer", key, unique, props, nodes);
}

function address(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "address", key, unique, props, nodes);
}

function main(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "main", key, unique, props, nodes);
}

function body(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "body", key, unique, props, nodes);
}

function figure(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "figure", key, unique, props, nodes);
}

function figcaption(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "figcaption", key, unique, props, nodes);
}

function table(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "table", key, unique, props, nodes);
}

function caption(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "caption", key, unique, props, nodes);
}

function colgroup(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "colgroup", key, unique, props, nodes);
}

function col(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "col", key, unique, props, nodes);
}

function tbody(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "tbody", key, unique, props, nodes);
}

function thead(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "thead", key, unique, props, nodes);
}

function tfoot(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "tfoot", key, unique, props, nodes);
}

function tr(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "tr", key, unique, props, nodes);
}

function th(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "th", key, unique, props, nodes);
}

function td(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "td", key, unique, props, nodes);
}

function datalist(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "datalist", key, unique, props, nodes);
}

function keygen(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "keygen", key, unique, props, nodes);
}

function output(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "output", key, unique, props, nodes);
}

function progress(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "progress", key, unique, props, nodes);
}

function meter(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "meter", key, unique, props, nodes);
}

function audio(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "audio", key, unique, props, nodes);
}

function video(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "video", key, unique, props, nodes);
}

function source(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "source", key, unique, props, nodes);
}

function track(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "track", key, unique, props, nodes);
}

function embed(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "embed", key, unique, props, nodes);
}

function object(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "object", key, unique, props, nodes);
}

function param(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "param", key, unique, props, nodes);
}

function ins(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "ins", key, unique, props, nodes);
}

function del(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "del", key, unique, props, nodes);
}

function small(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "small", key, unique, props, nodes);
}

function cite(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "cite", key, unique, props, nodes);
}

function dfn(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "dfn", key, unique, props, nodes);
}

function abbr(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "abbr", key, unique, props, nodes);
}

function time(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "time", key, unique, props, nodes);
}

function $$var(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "var", key, unique, props, nodes);
}

function samp(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "samp", key, unique, props, nodes);
}

function kbd(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "kbd", key, unique, props, nodes);
}

function s(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "s", key, unique, props, nodes);
}

function q(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "q", key, unique, props, nodes);
}

function mark(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "mark", key, unique, props, nodes);
}

function ruby(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "ruby", key, unique, props, nodes);
}

function rt(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "rt", key, unique, props, nodes);
}

function rp(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "rp", key, unique, props, nodes);
}

function bdi(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "bdi", key, unique, props, nodes);
}

function bdo(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "bdo", key, unique, props, nodes);
}

function wbr(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "wbr", key, unique, props, nodes);
}

function details(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "details", key, unique, props, nodes);
}

function summary(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "summary", key, unique, props, nodes);
}

function menuitem(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "menuitem", key, unique, props, nodes);
}

function menu(keyOpt, uniqueOpt, props, nodes) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "menu", key, unique, props, nodes);
}

function meta(keyOpt, uniqueOpt, props) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "meta", key, unique, props, /* [] */0);
}

function style(keyOpt, uniqueOpt, props, content) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "style", key, unique, props, {
              hd: {
                TAG: /* Text */1,
                _0: content
              },
              tl: /* [] */0
            });
}

function title(keyOpt, uniqueOpt, props, content) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "title", key, unique, props, {
              hd: {
                TAG: /* Text */1,
                _0: content
              },
              tl: /* [] */0
            });
}

function link(keyOpt, uniqueOpt, props) {
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return Vdom.fullnode("", "link", key, unique, props, /* [] */0);
}

var style$1 = Vdom.style;

function styles(s) {
  return {
          TAG: /* Style */4,
          _0: s
        };
}

function $$class(name) {
  return {
          TAG: /* RawProp */0,
          _0: "className",
          _1: name
        };
}

function classList(classes) {
  var xs = List.map((function (param) {
          return param[0];
        }), List.filter(function (param) {
              return param[1];
            })(classes));
  return {
          TAG: /* RawProp */0,
          _0: "className",
          _1: Belt_List.toArray(xs).join(" ")
        };
}

function id(str) {
  return {
          TAG: /* RawProp */0,
          _0: "id",
          _1: str
        };
}

function title$1(str) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "title",
          _2: str
        };
}

function hidden(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "hidden",
            _1: "hidden"
          };
  } else {
    return /* NoProp */0;
  }
}

function type$p(typ) {
  return {
          TAG: /* RawProp */0,
          _0: "type",
          _1: typ
        };
}

function value(str) {
  return {
          TAG: /* RawProp */0,
          _0: "value",
          _1: str
        };
}

function defaultValue(str) {
  return {
          TAG: /* RawProp */0,
          _0: "defaultValue",
          _1: str
        };
}

function checked(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "checked",
            _1: "checked"
          };
  } else {
    return /* NoProp */0;
  }
}

function placeholder(str) {
  return {
          TAG: /* RawProp */0,
          _0: "placeholder",
          _1: str
        };
}

function selected(b) {
  if (b) {
    return {
            TAG: /* Attribute */1,
            _0: "",
            _1: "selected",
            _2: "true"
          };
  } else {
    return /* NoProp */0;
  }
}

function accept(c) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "accept",
          _2: c
        };
}

function acceptCharset(c) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "accept-charset",
          _2: c
        };
}

function action(a) {
  return {
          TAG: /* RawProp */0,
          _0: "action",
          _1: a
        };
}

function autocomplete(b) {
  return {
          TAG: /* RawProp */0,
          _0: "autocomplete",
          _1: b ? "on" : "off"
        };
}

function autofocus(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "autofocus",
            _1: "autofocus"
          };
  } else {
    return /* NoProp */0;
  }
}

function disabled(b) {
  if (b) {
    return {
            TAG: /* Attribute */1,
            _0: "",
            _1: "disabled",
            _2: "true"
          };
  } else {
    return /* NoProp */0;
  }
}

function enctype(encoding) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "enctype",
          _2: encoding
        };
}

function formaction(url) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "formaction",
          _2: url
        };
}

function list(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "list",
          _2: value
        };
}

function minlength(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "minlength",
          _2: String(n)
        };
}

function maxlength(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "maxlength",
          _2: String(n)
        };
}

function method(m) {
  return {
          TAG: /* RawProp */0,
          _0: "method",
          _1: m
        };
}

function multiple(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "multiple",
            _1: "multiple"
          };
  } else {
    return /* NoProp */0;
  }
}

function name(str) {
  return {
          TAG: /* RawProp */0,
          _0: "name",
          _1: str
        };
}

function novalidate(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "novalidate",
            _1: "novalidate"
          };
  } else {
    return /* NoProp */0;
  }
}

function pattern(p) {
  return {
          TAG: /* RawProp */0,
          _0: "pattern",
          _1: p
        };
}

function readonly(b) {
  if (b) {
    return {
            TAG: /* Attribute */1,
            _0: "",
            _1: "readonly",
            _2: "readonly"
          };
  } else {
    return /* NoProp */0;
  }
}

function required(b) {
  if (b) {
    return {
            TAG: /* Attribute */1,
            _0: "",
            _1: "required",
            _2: "required"
          };
  } else {
    return /* NoProp */0;
  }
}

function size(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "size",
          _2: String(n)
        };
}

function for$p(str) {
  return {
          TAG: /* RawProp */0,
          _0: "htmlFor",
          _1: str
        };
}

function form$1(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "form",
          _2: value
        };
}

function max(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "max",
          _2: value
        };
}

function min(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "min",
          _2: value
        };
}

function step(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "step",
          _2: value
        };
}

function cols(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "cols",
          _2: String(n)
        };
}

function rows(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "rows",
          _2: String(n)
        };
}

function wrap(value) {
  return {
          TAG: /* RawProp */0,
          _0: "wrap",
          _1: value
        };
}

function href(str) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "href",
          _2: str
        };
}

function target(t) {
  return {
          TAG: /* RawProp */0,
          _0: "target",
          _1: t
        };
}

function download(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "download",
            _1: ""
          };
  } else {
    return /* NoProp */0;
  }
}

function downloadAs(name) {
  return {
          TAG: /* RawProp */0,
          _0: "download",
          _1: name
        };
}

function hreflang(code) {
  return {
          TAG: /* RawProp */0,
          _0: "hreflang",
          _1: code
        };
}

function media(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "media",
          _2: value
        };
}

function ping(url) {
  return {
          TAG: /* RawProp */0,
          _0: "ping",
          _1: url
        };
}

function rel(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "rel",
          _2: value
        };
}

function ismap(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "ismap",
            _1: "ismap"
          };
  } else {
    return /* NoProp */0;
  }
}

function usemap(name) {
  return {
          TAG: /* RawProp */0,
          _0: "usemap",
          _1: name
        };
}

function shape(value) {
  return {
          TAG: /* RawProp */0,
          _0: "shape",
          _1: value
        };
}

function coords(value) {
  return {
          TAG: /* RawProp */0,
          _0: "coords",
          _1: value
        };
}

function src(str) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "src",
          _2: str
        };
}

function height(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "height",
          _2: String(n)
        };
}

function width(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "width",
          _2: String(n)
        };
}

function alt(value) {
  return {
          TAG: /* RawProp */0,
          _0: "alt",
          _1: value
        };
}

function autoplay(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "autoplay",
            _1: "autoplay"
          };
  } else {
    return /* NoProp */0;
  }
}

function controls(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "controls",
            _1: "controls"
          };
  } else {
    return /* NoProp */0;
  }
}

function loop(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "loop",
            _1: "loop"
          };
  } else {
    return /* NoProp */0;
  }
}

function preload(value) {
  return {
          TAG: /* RawProp */0,
          _0: "preload",
          _1: value
        };
}

function poster(url) {
  return {
          TAG: /* RawProp */0,
          _0: "poster",
          _1: url
        };
}

function $$default(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "default",
            _1: "default"
          };
  } else {
    return /* NoProp */0;
  }
}

function kind(value) {
  return {
          TAG: /* RawProp */0,
          _0: "kind",
          _1: value
        };
}

function srclang(code) {
  return {
          TAG: /* RawProp */0,
          _0: "srclang",
          _1: code
        };
}

function sandbox(value) {
  return {
          TAG: /* RawProp */0,
          _0: "sandbox",
          _1: value
        };
}

function seamless(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "seamless",
            _1: "seamless"
          };
  } else {
    return /* NoProp */0;
  }
}

function srcdoc(value) {
  return {
          TAG: /* RawProp */0,
          _0: "srcdoc",
          _1: value
        };
}

function reversed(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "reversed",
            _1: "reversed"
          };
  } else {
    return /* NoProp */0;
  }
}

function start(n) {
  return {
          TAG: /* RawProp */0,
          _0: "start",
          _1: String(n)
        };
}

function colspan(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "colspan",
          _2: String(n)
        };
}

function rowspan(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "rowspan",
          _2: String(n)
        };
}

function headers(value) {
  return {
          TAG: /* RawProp */0,
          _0: "headers",
          _1: value
        };
}

function scope(value) {
  return {
          TAG: /* RawProp */0,
          _0: "scope",
          _1: value
        };
}

function align(value) {
  return {
          TAG: /* RawProp */0,
          _0: "align",
          _1: value
        };
}

function async(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "async",
            _1: "async"
          };
  } else {
    return /* NoProp */0;
  }
}

function charset(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "charset",
          _2: value
        };
}

function content(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "content",
          _2: value
        };
}

function defer(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "defer",
            _1: "defer"
          };
  } else {
    return /* NoProp */0;
  }
}

function httpEquiv(value) {
  return {
          TAG: /* RawProp */0,
          _0: "http-equiv",
          _1: value
        };
}

function language(value) {
  return {
          TAG: /* RawProp */0,
          _0: "language",
          _1: value
        };
}

function scoped(value) {
  return {
          TAG: /* RawProp */0,
          _0: "scoped",
          _1: value
        };
}

function accesskey(ch) {
  return {
          TAG: /* RawProp */0,
          _0: "accesskey",
          _1: Caml_string.make(1, ch)
        };
}

function contenteditable(b) {
  if (b) {
    return {
            TAG: /* RawProp */0,
            _0: "contenteditable",
            _1: "contenteditable"
          };
  } else {
    return /* NoProp */0;
  }
}

function contextmenu(id) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "contextmenu",
          _2: id
        };
}

function dir(value) {
  return {
          TAG: /* RawProp */0,
          _0: "dir",
          _1: value
        };
}

function draggable(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "draggable",
          _2: value
        };
}

function dropzone(value) {
  return {
          TAG: /* RawProp */0,
          _0: "dropzone",
          _1: value
        };
}

function itemprop(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "itemprop",
          _2: value
        };
}

function lang(code) {
  return {
          TAG: /* RawProp */0,
          _0: "lang",
          _1: code
        };
}

function spellcheck(b) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "spellcheck",
          _2: b ? "true" : "false"
        };
}

function tabindex(n) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "tabindex",
          _2: String(n)
        };
}

function challenge(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "challenge",
          _2: value
        };
}

function keytype(value) {
  return {
          TAG: /* RawProp */0,
          _0: "keytype",
          _1: value
        };
}

function cite$1(url) {
  return {
          TAG: /* RawProp */0,
          _0: "cite",
          _1: url
        };
}

function datetime(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "datetime",
          _2: value
        };
}

function pubdate(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "pubdate",
          _2: value
        };
}

function manifest(value) {
  return {
          TAG: /* Attribute */1,
          _0: "",
          _1: "manifest",
          _2: value
        };
}

function role(name) {
  return {
          TAG: /* RawProp */0,
          _0: "role",
          _1: name
        };
}

function ariaChecked(v) {
  return {
          TAG: /* RawProp */0,
          _0: "aria-checked",
          _1: v ? "true" : "false"
        };
}

function ariaHidden(v) {
  return {
          TAG: /* RawProp */0,
          _0: "aria-hidden",
          _1: v ? "true" : "false"
        };
}

var Attributes = {
  noProp: /* NoProp */0,
  style: style$1,
  styles: styles,
  $$class: $$class,
  classList: classList,
  id: id,
  title: title$1,
  hidden: hidden,
  type$p: type$p,
  value: value,
  defaultValue: defaultValue,
  checked: checked,
  placeholder: placeholder,
  selected: selected,
  accept: accept,
  acceptCharset: acceptCharset,
  action: action,
  autocomplete: autocomplete,
  autofocus: autofocus,
  disabled: disabled,
  enctype: enctype,
  formaction: formaction,
  list: list,
  minlength: minlength,
  maxlength: maxlength,
  method: method,
  multiple: multiple,
  name: name,
  novalidate: novalidate,
  pattern: pattern,
  readonly: readonly,
  required: required,
  size: size,
  for$p: for$p,
  form: form$1,
  max: max,
  min: min,
  step: step,
  cols: cols,
  rows: rows,
  wrap: wrap,
  href: href,
  target: target,
  download: download,
  downloadAs: downloadAs,
  hreflang: hreflang,
  media: media,
  ping: ping,
  rel: rel,
  ismap: ismap,
  usemap: usemap,
  shape: shape,
  coords: coords,
  src: src,
  height: height,
  width: width,
  alt: alt,
  autoplay: autoplay,
  controls: controls,
  loop: loop,
  preload: preload,
  poster: poster,
  $$default: $$default,
  kind: kind,
  srclang: srclang,
  sandbox: sandbox,
  seamless: seamless,
  srcdoc: srcdoc,
  reversed: reversed,
  start: start,
  colspan: colspan,
  rowspan: rowspan,
  headers: headers,
  scope: scope,
  align: align,
  async: async,
  charset: charset,
  content: content,
  defer: defer,
  httpEquiv: httpEquiv,
  language: language,
  scoped: scoped,
  accesskey: accesskey,
  contenteditable: contenteditable,
  contextmenu: contextmenu,
  dir: dir,
  draggable: draggable,
  dropzone: dropzone,
  itemprop: itemprop,
  lang: lang,
  spellcheck: spellcheck,
  tabindex: tabindex,
  challenge: challenge,
  keytype: keytype,
  cite: cite$1,
  datetime: datetime,
  pubdate: pubdate,
  manifest: manifest,
  role: role,
  ariaChecked: ariaChecked,
  ariaHidden: ariaHidden
};

var onCB = Vdom.onCB;

var onMsg = Vdom.onMsg;

var defaultOptions = {
  stopPropagation: false,
  preventDefault: false
};

function onWithOptions(key, eventName, options, decoder) {
  return Vdom.onCB(key, eventName, (function ($$event) {
                if (options.stopPropagation) {
                  $$event.stopPropagation();
                }
                if (options.preventDefault) {
                  $$event.preventDefault();
                }
                return Tea_result.resultToOption(Tea_json.Decoder.decodeEvent(decoder, $$event));
              }));
}

function on(key, eventName, decoder) {
  return onWithOptions(key, eventName, defaultOptions, decoder);
}

var targetValue = Tea_json.Decoder.at({
      hd: "target",
      tl: {
        hd: "value",
        tl: /* [] */0
      }
    }, Tea_json.Decoder.string);

var targetChecked = Tea_json.Decoder.at({
      hd: "target",
      tl: {
        hd: "checked",
        tl: /* [] */0
      }
    }, Tea_json.Decoder.bool);

var keyCode = Tea_json.Decoder.field("keyCode", Tea_json.Decoder.$$int);

function preventDefaultOn(keyOpt, eventName, decoder) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return onWithOptions(key, eventName, {
              stopPropagation: false,
              preventDefault: true
            }, decoder);
}

function onClick(msg) {
  return Vdom.onMsg("click", msg);
}

function onDoubleClick(msg) {
  return Vdom.onMsg("dblclick", msg);
}

function onMouseDown(msg) {
  return Vdom.onMsg("mousedown", msg);
}

function onMouseUp(msg) {
  return Vdom.onMsg("mouseup", msg);
}

function onMouseEnter(msg) {
  return Vdom.onMsg("mouseenter", msg);
}

function onMouseLeave(msg) {
  return Vdom.onMsg("mouseleave", msg);
}

function onMouseOver(msg) {
  return Vdom.onMsg("mouseover", msg);
}

function onMouseOut(msg) {
  return Vdom.onMsg("mouseout", msg);
}

function onInputOpt(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return Vdom.onCB(key, "input", (function (ev) {
                var element = ev.target;
                var inputElement = Webapi__Dom__HtmlElement.ofElement(element);
                if (inputElement !== undefined) {
                  return Curry._1(msg, Caml_option.valFromOption(inputElement).value);
                }
                
              }));
}

function onInput(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return onInputOpt(key, (function (ev) {
                return Caml_option.some(Curry._1(msg, ev));
              }));
}

function onCheckOpt(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return Vdom.onCB(key, "check", (function (ev) {
                var element = ev.target;
                var inputElement = Webapi__Dom__HtmlElement.ofElement(element);
                if (inputElement !== undefined) {
                  return Curry._1(msg, Caml_option.valFromOption(inputElement).checked);
                }
                
              }));
}

function onCheck(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return onCheckOpt(key, (function (ev) {
                return Caml_option.some(Curry._1(msg, ev));
              }));
}

function onChangeOpt(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return Vdom.onCB(key, "change", (function (ev) {
                var element = ev.target;
                var inputElement = Webapi__Dom__HtmlElement.ofElement(element);
                if (inputElement !== undefined) {
                  return Curry._1(msg, Caml_option.valFromOption(inputElement).value);
                }
                
              }));
}

function onChange(keyOpt, msg) {
  var key = keyOpt !== undefined ? keyOpt : "";
  return onChangeOpt(key, (function (ev) {
                return Caml_option.some(Curry._1(msg, ev));
              }));
}

function onSubmit(msg) {
  return preventDefaultOn(undefined, "submit", Tea_json.Decoder.succeed(msg));
}

function onBlur(msg) {
  return Vdom.onMsg("blur", msg);
}

function onFocus(msg) {
  return Vdom.onMsg("focus", msg);
}

var map = Vdom.map;

var noNode = Vdom.noNode;

var Events = {
  onCB: onCB,
  onMsg: onMsg,
  on: on,
  onWithOptions: onWithOptions,
  defaultOptions: defaultOptions,
  targetValue: targetValue,
  targetChecked: targetChecked,
  keyCode: keyCode,
  preventDefaultOn: preventDefaultOn,
  onClick: onClick,
  onDoubleClick: onDoubleClick,
  onMouseDown: onMouseDown,
  onMouseUp: onMouseUp,
  onMouseEnter: onMouseEnter,
  onMouseLeave: onMouseLeave,
  onMouseOver: onMouseOver,
  onMouseOut: onMouseOut,
  onInputOpt: onInputOpt,
  onInput: onInput,
  onCheckOpt: onCheckOpt,
  onCheck: onCheck,
  onChangeOpt: onChangeOpt,
  onChange: onChange,
  onSubmit: onSubmit,
  onBlur: onBlur,
  onFocus: onFocus
};

exports.map = map;
exports.text = text;
exports.node = node;
exports.noNode = noNode;
exports.lazy1 = lazy1;
exports.h1 = h1;
exports.h2 = h2;
exports.h3 = h3;
exports.h4 = h4;
exports.h5 = h5;
exports.h6 = h6;
exports.div = div;
exports.p = p;
exports.hr = hr;
exports.pre = pre;
exports.blockquote = blockquote;
exports.span = span;
exports.a = a;
exports.code = code;
exports.em = em;
exports.strong = strong;
exports.i = i;
exports.b = b;
exports.u = u;
exports.sub = sub;
exports.sup = sup;
exports.br = br;
exports.br$p = br$p;
exports.ol = ol;
exports.ul = ul;
exports.li = li;
exports.dl = dl;
exports.dt = dt;
exports.dd = dd;
exports.img = img;
exports.iframe = iframe;
exports.canvas = canvas;
exports.math = math;
exports.form = form;
exports.input$p = input$p;
exports.textarea = textarea;
exports.button = button;
exports.select = select;
exports.option = option;
exports.optgroup = optgroup;
exports.label = label;
exports.fieldset = fieldset;
exports.legend = legend;
exports.section = section;
exports.nav = nav;
exports.article = article;
exports.aside = aside;
exports.header = header;
exports.footer = footer;
exports.address = address;
exports.main = main;
exports.body = body;
exports.figure = figure;
exports.figcaption = figcaption;
exports.table = table;
exports.caption = caption;
exports.colgroup = colgroup;
exports.col = col;
exports.tbody = tbody;
exports.thead = thead;
exports.tfoot = tfoot;
exports.tr = tr;
exports.th = th;
exports.td = td;
exports.datalist = datalist;
exports.keygen = keygen;
exports.output = output;
exports.progress = progress;
exports.meter = meter;
exports.audio = audio;
exports.video = video;
exports.source = source;
exports.track = track;
exports.embed = embed;
exports.object = object;
exports.param = param;
exports.ins = ins;
exports.del = del;
exports.small = small;
exports.cite = cite;
exports.dfn = dfn;
exports.abbr = abbr;
exports.time = time;
exports.$$var = $$var;
exports.samp = samp;
exports.kbd = kbd;
exports.s = s;
exports.q = q;
exports.mark = mark;
exports.ruby = ruby;
exports.rt = rt;
exports.rp = rp;
exports.bdi = bdi;
exports.bdo = bdo;
exports.wbr = wbr;
exports.details = details;
exports.summary = summary;
exports.menuitem = menuitem;
exports.menu = menu;
exports.meta = meta;
exports.style = style;
exports.title = title;
exports.link = link;
exports.Attributes = Attributes;
exports.Events = Events;
/* targetValue Not a pure module */

},{"./tea_json.bs.js":4,"./tea_result.bs.js":5,"./vdom.bs.js":7,"rescript-webapi/src/Webapi/Dom/Webapi__Dom__HtmlElement.bs.js":12,"rescript/lib/js/belt_List.js":20,"rescript/lib/js/caml_option.js":33,"rescript/lib/js/caml_string.js":35,"rescript/lib/js/curry.js":37,"rescript/lib/js/list.js":43}],4:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var $$Array = require("rescript/lib/js/array.js");
var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Tea_result = require("./tea_result.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var ParseFail = /* @__PURE__ */Caml_exceptions.create("Tea_json.Decoder.ParseFail");

var string = /* Decoder */{
  _0: (function (value) {
      var s = Js_json.classify(value);
      if (typeof s === "number" || s.TAG !== /* JSONString */0) {
        return {
                TAG: /* Error */1,
                _0: "Non-string value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: s._0
              };
      }
    })
};

var $$int = /* Decoder */{
  _0: (function (value) {
      var n = Js_json.classify(value);
      if (typeof n === "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      if (n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      var n$1 = n._0;
      if (n$1 > Pervasives.min_int && n$1 < Pervasives.max_int) {
        return {
                TAG: /* Ok */0,
                _0: n$1 | 0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: "number out of int range"
              };
      }
    })
};

var $$float = /* Decoder */{
  _0: (function (value) {
      var n = Js_json.classify(value);
      if (typeof n === "number" || n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-float-value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: n._0
              };
      }
    })
};

var bool = /* Decoder */{
  _0: (function (value) {
      var match = Js_json.classify(value);
      if (typeof match !== "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-boolean value"
              };
      }
      switch (match) {
        case /* JSONFalse */0 :
            return {
                    TAG: /* Ok */0,
                    _0: false
                  };
        case /* JSONTrue */1 :
            return {
                    TAG: /* Ok */0,
                    _0: true
                  };
        case /* JSONNull */2 :
            return {
                    TAG: /* Error */1,
                    _0: "Non-boolean value"
                  };
        
      }
    })
};

function $$null(v) {
  return /* Decoder */{
          _0: (function (value) {
              var match = Js_json.classify(value);
              if (typeof match === "number" && match >= 2) {
                return {
                        TAG: /* Ok */0,
                        _0: v
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "Non-null value"
                      };
              }
            })
        };
}

function list(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Js_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: List.map(parse, $$Array.to_list(a._0))
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "list -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function array(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Js_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.map(parse, a._0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "array -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function keyValuePairs(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Js_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, l) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return {
                            hd: [
                              k,
                              r._0
                            ],
                            tl: l
                          };
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, /* [] */0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid keyValuePair parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function dict(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Js_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, d) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return Belt_MapString.set(d, k, r._0);
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, undefined)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid dict parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function field(key, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Js_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              var v = Js_dict.get(o._0, key);
              if (v === undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "Field Value is undefined: " + key
                      };
              }
              var o$1 = Curry._1(decoder$1, Caml_option.valFromOption(v));
              if (o$1.TAG === /* Ok */0) {
                return o$1;
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "field `" + (key + ("` -> " + o$1._0))
                      };
              }
            })
        };
}

function at(fields, dec) {
  return List.fold_right(field, fields, dec);
}

function index(idx, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Js_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var a$1 = a._0;
              if (idx < 0 || idx > a$1.length) {
                return {
                        TAG: /* Error */1,
                        _0: "Array index out of range: " + String(idx)
                      };
              } else {
                return Curry._1(decoder$1, Caml_array.get(a$1, idx));
              }
            })
        };
}

function maybe(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Caml_option.some(r._0)
                      };
              } else {
                return {
                        TAG: /* Ok */0,
                        _0: undefined
                      };
              }
            })
        };
}

function oneOf(decoders) {
  return /* Decoder */{
          _0: (function (value) {
              var parse = function (v, _x) {
                while(true) {
                  var x = _x;
                  if (!x) {
                    return {
                            TAG: /* Error */1,
                            _0: "No one-of's matched"
                          };
                  }
                  var rest = x.tl;
                  try {
                    var ok = Curry._1(x.hd._0, v);
                    if (ok.TAG === /* Ok */0) {
                      return ok;
                    } else {
                      return parse(v, rest);
                    }
                  }
                  catch (exn){
                    _x = rest;
                    continue ;
                  }
                };
              };
              return parse(value, decoders);
            })
        };
}

function map(mapper, decoder1) {
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var v1 = Curry._1(decoder1$1, value);
              if (v1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._1(mapper, v1._0)
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "map " + v1._0
                      };
              }
            })
        };
}

function map2(mapper, decoder1, decoder2) {
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._2(mapper, match._0, match$1._0)
                      };
              }
              var e = Tea_result.errorOfFirst(match, match$1);
              if (e !== undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "map2 -> " + e
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map3(mapper, decoder1, decoder2, decoder3) {
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._3(mapper, match._0, match$1._0, match$2._0)
                      };
              }
              var e = Tea_result.first(match$2, Tea_result.first(match$1, match));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map3 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map4(mapper, decoder1, decoder2, decoder3, decoder4) {
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._4(mapper, match._0, match$1._0, match$2._0, match$3._0)
                      };
              }
              var e = Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map4 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map5(mapper, decoder1, decoder2, decoder3, decoder4, decoder5) {
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._5(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0)
                      };
              }
              var e = Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map5 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map6(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6) {
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._6(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0)
                      };
              }
              var e = Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map6 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map7(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7) {
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._7(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0)
                      };
              }
              var e = Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map7 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map8(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7, decoder8) {
  var decoder8$1 = decoder8._0;
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              var match$7 = Curry._1(decoder8$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0 && match$7.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._8(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0, match$7._0)
                      };
              }
              var e = Tea_result.first(match$7, Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map8 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function succeed(v) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Ok */0,
                      _0: v
                    };
            })
        };
}

function fail(e) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Error */1,
                      _0: e
                    };
            })
        };
}

var value = /* Decoder */{
  _0: (function (value) {
      return {
              TAG: /* Ok */0,
              _0: value
            };
    })
};

function andThen(func, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG !== /* Ok */0) {
                return r;
              }
              var andThenDecoder = Curry._1(func, r._0);
              return Curry._1(andThenDecoder._0, value);
            })
        };
}

function lazy_(func) {
  return andThen(func, /* Decoder */{
              _0: (function (_value) {
                  return {
                          TAG: /* Ok */0,
                          _0: undefined
                        };
                })
            });
}

function nullable(decoder) {
  return oneOf({
              hd: $$null(undefined),
              tl: {
                hd: map((function (v) {
                        return Caml_option.some(v);
                      }), decoder),
                tl: /* [] */0
              }
            });
}

function decodeValue(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeEvent(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeString(decoder, string) {
  try {
    var value = JSON.parse(string);
    return decodeValue(decoder, value);
  }
  catch (exn){
    return {
            TAG: /* Error */1,
            _0: "Invalid JSON string"
          };
  }
}

function encode(indentLevel, value) {
  if (value === undefined) {
    return "undefined";
  }
  try {
    return JSON.stringify(value, null, indentLevel);
  }
  catch (exn){
    return "";
  }
}

function string$1(v) {
  return v;
}

function $$int$1(v) {
  return v;
}

function $$float$1(v) {
  return v;
}

function bool$1(v) {
  return v;
}

var $$null$1 = null;

function object_(v) {
  var aux = function (o, param) {
    o[param[0]] = param[1];
    return o;
  };
  return List.fold_left(aux, {}, v);
}

function array$1(v) {
  return Curry._1(/* Array */3, v);
}

var list$1 = $$Array.of_list;

var Encoder = {
  encode: encode,
  string: string$1,
  $$int: $$int$1,
  $$float: $$float$1,
  bool: bool$1,
  $$null: $$null$1,
  object_: object_,
  array: array$1,
  list: list$1
};

var Decoder_ObjectDict = {};

var Decoder = {
  ObjectDict: Decoder_ObjectDict,
  ParseFail: ParseFail,
  string: string,
  $$int: $$int,
  $$float: $$float,
  bool: bool,
  $$null: $$null,
  list: list,
  array: array,
  keyValuePairs: keyValuePairs,
  dict: dict,
  field: field,
  at: at,
  index: index,
  maybe: maybe,
  oneOf: oneOf,
  map: map,
  map2: map2,
  map3: map3,
  map4: map4,
  map5: map5,
  map6: map6,
  map7: map7,
  map8: map8,
  succeed: succeed,
  fail: fail,
  value: value,
  andThen: andThen,
  lazy_: lazy_,
  nullable: nullable,
  decodeValue: decodeValue,
  decodeEvent: decodeEvent,
  decodeString: decodeString
};

exports.Decoder = Decoder;
exports.Encoder = Encoder;
/* null Not a pure module */

},{"./tea_result.bs.js":5,"rescript/lib/js/array.js":18,"rescript/lib/js/belt_MapString.js":21,"rescript/lib/js/caml_array.js":27,"rescript/lib/js/caml_exceptions.js":28,"rescript/lib/js/caml_js_exceptions.js":31,"rescript/lib/js/caml_option.js":33,"rescript/lib/js/curry.js":37,"rescript/lib/js/js_dict.js":39,"rescript/lib/js/js_json.js":41,"rescript/lib/js/list.js":43,"rescript/lib/js/pervasives.js":44}],5:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");

function resultToOption(x) {
  if (x.TAG === /* Ok */0) {
    return Caml_option.some(x._0);
  }
  
}

function first(fst, x) {
  if (x.TAG === /* Ok */0) {
    return fst;
  } else {
    return x;
  }
}

function errorOfFirst(fst, x) {
  if (x.TAG === /* Ok */0) {
    if (fst.TAG === /* Ok */0) {
      return ;
    } else {
      return Caml_option.some(fst._0);
    }
  } else {
    return Caml_option.some(x._0);
  }
}

exports.first = first;
exports.resultToOption = resultToOption;
exports.errorOfFirst = errorOfFirst;
/* No side effect */

},{"rescript/lib/js/caml_option.js":33}],6:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Vdom = require("./vdom.bs.js");
var Curry = require("rescript/lib/js/curry.js");

function batch(subs) {
  return {
          TAG: /* Batch */0,
          _0: subs
        };
}

function registration(key, enableCall) {
  return {
          TAG: /* Registration */1,
          _0: key,
          _1: (function (callbacks) {
              return Curry._1(enableCall, callbacks.contents);
            }),
          _2: {
            contents: undefined
          }
        };
}

function map(msgMapper, sub) {
  var func = function (callbacks) {
    return Vdom.wrapCallbacks(msgMapper, callbacks);
  };
  return {
          TAG: /* Mapper */2,
          _0: func,
          _1: sub
        };
}

function mapFunc(func, sub) {
  return {
          TAG: /* Mapper */2,
          _0: func,
          _1: sub
        };
}

function run(oldCallbacks, newCallbacks, oldSub, newSub) {
  var enable = function (_callbacks, _x) {
    while(true) {
      var x = _x;
      var callbacks = _callbacks;
      if (typeof x === "number") {
        return ;
      }
      switch (x.TAG | 0) {
        case /* Batch */0 :
            var subs = x._0;
            if (subs) {
              return List.iter((function(callbacks){
                        return function (param) {
                          return enable(callbacks, param);
                        }
                        }(callbacks)), subs);
            } else {
              return ;
            }
        case /* Registration */1 :
            x._2.contents = Curry._1(x._1, callbacks);
            return ;
        case /* Mapper */2 :
            var subCallbacks = Curry._1(x._0, callbacks);
            _x = x._1;
            _callbacks = subCallbacks;
            continue ;
        
      }
    };
  };
  var disable = function (_callbacks, _x) {
    while(true) {
      var x = _x;
      var callbacks = _callbacks;
      if (typeof x === "number") {
        return ;
      }
      switch (x.TAG | 0) {
        case /* Batch */0 :
            var subs = x._0;
            if (subs) {
              return List.iter((function(callbacks){
                        return function (param) {
                          return disable(callbacks, param);
                        }
                        }(callbacks)), subs);
            } else {
              return ;
            }
        case /* Registration */1 :
            var diCB = x._2;
            var cb = diCB.contents;
            if (cb !== undefined) {
              diCB.contents = undefined;
              return Curry._1(cb, undefined);
            } else {
              return ;
            }
        case /* Mapper */2 :
            var subCallbacks = Curry._1(x._0, callbacks);
            _x = x._1;
            _callbacks = subCallbacks;
            continue ;
        
      }
    };
  };
  if (typeof oldSub === "number") {
    if (typeof newSub === "number") {
      return newSub;
    }
    
  } else {
    switch (oldSub.TAG | 0) {
      case /* Batch */0 :
          if (typeof newSub !== "number" && newSub.TAG === /* Batch */0) {
            var aux = function (_oldList, _newList) {
              while(true) {
                var newList = _newList;
                var oldList = _oldList;
                if (oldList) {
                  var oldRest = oldList.tl;
                  var oldSubSub = oldList.hd;
                  if (newList) {
                    run(oldCallbacks, newCallbacks, oldSubSub, newList.hd);
                    _newList = newList.tl;
                    _oldList = oldRest;
                    continue ;
                  }
                  disable(oldCallbacks, oldSubSub);
                  _newList = /* [] */0;
                  _oldList = oldRest;
                  continue ;
                }
                if (!newList) {
                  return ;
                }
                enable(newCallbacks, newList.hd);
                _newList = newList.tl;
                _oldList = /* [] */0;
                continue ;
              };
            };
            aux(oldSub._0, newSub._0);
            return newSub;
          }
          break;
      case /* Registration */1 :
          if (typeof newSub !== "number" && newSub.TAG === /* Registration */1 && oldSub._0 === newSub._0) {
            newSub._2.contents = oldSub._2.contents;
            return newSub;
          }
          break;
      case /* Mapper */2 :
          if (typeof newSub !== "number" && newSub.TAG === /* Mapper */2) {
            var olderCallbacks = Curry._1(oldSub._0, oldCallbacks);
            var newerCallbacks = Curry._1(newSub._0, newCallbacks);
            run(olderCallbacks, newerCallbacks, oldSub._1, newSub._1);
            return newSub;
          }
          break;
      
    }
  }
  disable(oldCallbacks, oldSub);
  enable(newCallbacks, newSub);
  return newSub;
}

var none = /* NoSub */0;

exports.none = none;
exports.batch = batch;
exports.registration = registration;
exports.map = map;
exports.mapFunc = mapFunc;
exports.run = run;
/* Vdom Not a pure module */

},{"./vdom.bs.js":7,"rescript/lib/js/curry.js":37,"rescript/lib/js/list.js":43}],7:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Webapi__Dom__Element = require("rescript-webapi/src/Webapi/Dom/Webapi__Dom__Element.bs.js");
var Webapi__Dom__HtmlElement = require("rescript-webapi/src/Webapi/Dom/Webapi__Dom__HtmlElement.bs.js");

var noNode = {
  TAG: /* CommentNode */0,
  _0: ""
};

function comment(s) {
  return {
          TAG: /* CommentNode */0,
          _0: s
        };
}

function text(s) {
  return {
          TAG: /* Text */1,
          _0: s
        };
}

function fullnode(namespace, tagName, key, unique, props, vdoms) {
  return {
          TAG: /* Node */2,
          _0: namespace,
          _1: tagName,
          _2: key,
          _3: unique,
          _4: props,
          _5: vdoms
        };
}

function node(namespaceOpt, tagName, keyOpt, uniqueOpt, props, vdoms) {
  var namespace = namespaceOpt !== undefined ? namespaceOpt : "";
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return fullnode(namespace, tagName, key, unique, props, vdoms);
}

function lazyGen(key, fn) {
  return {
          TAG: /* LazyGen */3,
          _0: key,
          _1: fn,
          _2: {
            contents: noNode
          }
        };
}

function prop(propName, value) {
  return {
          TAG: /* RawProp */0,
          _0: propName,
          _1: value
        };
}

function onCB(key, eventName, cb) {
  return {
          TAG: /* Event */3,
          _0: eventName,
          _1: {
            TAG: /* EventHandlerCallback */0,
            _0: key,
            _1: cb
          },
          _2: {
            contents: undefined
          }
        };
}

function onMsg(name, msg) {
  return {
          TAG: /* Event */3,
          _0: name,
          _1: {
            TAG: /* EventHandlerMsg */1,
            _0: msg
          },
          _2: {
            contents: undefined
          }
        };
}

function attribute(namespace, key, value) {
  return {
          TAG: /* Attribute */1,
          _0: namespace,
          _1: key,
          _2: value
        };
}

function data(key, value) {
  return {
          TAG: /* Data */2,
          _0: key,
          _1: value
        };
}

function style(key, value) {
  return {
          TAG: /* Style */4,
          _0: {
            hd: [
              key,
              value
            ],
            tl: /* [] */0
          }
        };
}

function styles(s) {
  return {
          TAG: /* Style */4,
          _0: s
        };
}

function createElementNsOptional(namespace, tagName) {
  var $$document$1 = document;
  if (namespace === "") {
    return $$document$1.createElement(tagName);
  } else {
    return $$document$1.createElementNS(namespace, tagName);
  }
}

function nodeAt(index, nodes) {
  return Belt_Option.getExn(Caml_option.nullable_to_opt(nodes.item(index)));
}

function renderToHtmlString(_x) {
  while(true) {
    var x = _x;
    switch (x.TAG | 0) {
      case /* CommentNode */0 :
          return "<!-- " + (x._0 + " -->");
      case /* Text */1 :
          return x._0;
      case /* Node */2 :
          var tagName = x._1;
          var namespace = x._0;
          var xs = List.map((function (p) {
                  if (typeof p === "number") {
                    return "";
                  }
                  switch (p.TAG | 0) {
                    case /* RawProp */0 :
                        var xs_1 = {
                          hd: p._0,
                          tl: {
                            hd: "=\"",
                            tl: {
                              hd: p._1,
                              tl: {
                                hd: "\"",
                                tl: /* [] */0
                              }
                            }
                          }
                        };
                        var xs = {
                          hd: " ",
                          tl: xs_1
                        };
                        return Belt_List.toArray(xs).join("");
                    case /* Attribute */1 :
                        var xs_1$1 = {
                          hd: p._1,
                          tl: {
                            hd: "=\"",
                            tl: {
                              hd: p._2,
                              tl: {
                                hd: "\"",
                                tl: /* [] */0
                              }
                            }
                          }
                        };
                        var xs$1 = {
                          hd: " ",
                          tl: xs_1$1
                        };
                        return Belt_List.toArray(xs$1).join("");
                    case /* Data */2 :
                        var xs_1$2 = {
                          hd: p._0,
                          tl: {
                            hd: "=\"",
                            tl: {
                              hd: p._1,
                              tl: {
                                hd: "\"",
                                tl: /* [] */0
                              }
                            }
                          }
                        };
                        var xs$2 = {
                          hd: " data-",
                          tl: xs_1$2
                        };
                        return Belt_List.toArray(xs$2).join("");
                    case /* Event */3 :
                        return "";
                    case /* Style */4 :
                        var xs$3 = List.map((function (param) {
                                var xs_0 = param[0];
                                var xs_1 = {
                                  hd: ":",
                                  tl: {
                                    hd: param[1],
                                    tl: {
                                      hd: ";",
                                      tl: /* [] */0
                                    }
                                  }
                                };
                                var xs = {
                                  hd: xs_0,
                                  tl: xs_1
                                };
                                return Belt_List.toArray(xs).join("");
                              }), p._0);
                        var xs_1$3 = {
                          hd: Belt_List.toArray(xs$3).join(";"),
                          tl: {
                            hd: "\"",
                            tl: /* [] */0
                          }
                        };
                        var xs$4 = {
                          hd: " style=\"",
                          tl: xs_1$3
                        };
                        return Belt_List.toArray(xs$4).join("");
                    
                  }
                }), x._4);
          var xs$1 = List.map(renderToHtmlString, x._5);
          var xs_1 = {
            hd: namespace,
            tl: {
              hd: namespace === "" ? "" : ":",
              tl: {
                hd: tagName,
                tl: {
                  hd: Belt_List.toArray(xs).join(""),
                  tl: {
                    hd: ">",
                    tl: {
                      hd: Belt_List.toArray(xs$1).join(""),
                      tl: {
                        hd: "</",
                        tl: {
                          hd: tagName,
                          tl: {
                            hd: ">",
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          var xs$2 = {
            hd: "<",
            tl: xs_1
          };
          return Belt_List.toArray(xs$2).join("");
      case /* LazyGen */3 :
          _x = Curry._1(x._1, undefined);
          continue ;
      case /* Tagger */4 :
          _x = x._1;
          continue ;
      
    }
  };
}

function emptyEventHandler(_ev) {
  
}

function emptyEventCB(_ev) {
  
}

function eventHandler(callbacks, cb, ev) {
  var msg = Curry._1(cb.contents, ev);
  if (msg !== undefined) {
    return Curry._1(callbacks.contents.enqueue, Caml_option.valFromOption(msg));
  }
  
}

function eventHandlerGetCB(x) {
  if (x.TAG === /* EventHandlerCallback */0) {
    return x._1;
  }
  var msg = x._0;
  return function (_ev) {
    return Caml_option.some(msg);
  };
}

function compareEventHandlerTypes(left, x) {
  if (x.TAG === /* EventHandlerCallback */0) {
    if (left.TAG === /* EventHandlerCallback */0) {
      return x._0 === left._0;
    } else {
      return false;
    }
  } else if (left.TAG === /* EventHandlerCallback */0 || !Caml_obj.equal(x._0, left._0)) {
    return false;
  } else {
    return true;
  }
}

function eventHandlerRegister(callbacks, elem, name, handlerType) {
  var cb = {
    contents: eventHandlerGetCB(handlerType)
  };
  var handler = function (param) {
    return eventHandler(callbacks, cb, param);
  };
  elem.addEventListener(name, handler);
  return {
          handler: handler,
          cb: cb
        };
}

function eventHandlerUnregister(elem, name, x) {
  if (x !== undefined) {
    elem.removeEventListener(name, x.handler);
    return ;
  }
  
}

function eventHandlerMutate(callbacks, elem, oldName, newName, oldHandlerType, newHandlerType, oldCache, newCache) {
  var oldcache = oldCache.contents;
  if (oldcache === undefined) {
    newCache.contents = eventHandlerRegister(callbacks, elem, newName, newHandlerType);
    return ;
  }
  if (oldName === newName) {
    newCache.contents = oldCache.contents;
    if (compareEventHandlerTypes(oldHandlerType, newHandlerType)) {
      return ;
    }
    var cb = eventHandlerGetCB(newHandlerType);
    oldcache.cb.contents = cb;
    return ;
  }
  oldCache.contents = eventHandlerUnregister(elem, oldName, oldCache.contents);
  newCache.contents = eventHandlerRegister(callbacks, elem, newName, newHandlerType);
}

function patchVNodesOnElemsPropertiesApplyAdd(callbacks, elem, _idx, x) {
  if (typeof x === "number") {
    return ;
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        elem[x._0] = x._1;
        return ;
    case /* Attribute */1 :
        elem.setAttributeNS(x._0, x._1, x._2);
        return ;
    case /* Data */2 :
        console.log([
              "TODO:  Add Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Add Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        x._2.contents = eventHandlerRegister(callbacks, elem, x._0, x._1);
        return ;
    case /* Style */4 :
        var elem$1 = Webapi__Dom__HtmlElement.ofElement(elem);
        if (elem$1 !== undefined) {
          var elemStyle = Caml_option.valFromOption(elem$1).style;
          return List.fold_left((function (param, param$1) {
                        elemStyle.setProperty(param$1[0], param$1[1]);
                      }), undefined, x._0);
        }
        throw {
              RE_EXN_ID: "Failure",
              _1: "Expected htmlelement in patchVNodesOnElems_PropertiesApplyAdd",
              Error: new Error()
            };
    
  }
}

function patchVNodesOnElemsPropertiesApplyRemove(_callbacks, elem, _idx, x) {
  if (typeof x === "number") {
    return ;
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        var key = x._0;
        elem[key] = undefined;
        return ;
    case /* Attribute */1 :
        elem.removeAttributeNS(x._0, x._1);
        return ;
    case /* Data */2 :
        console.log([
              "TODO:  Remove Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Remove Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        var cache = x._2;
        cache.contents = eventHandlerUnregister(elem, x._0, cache.contents);
        return ;
    case /* Style */4 :
        var elem$1 = Webapi__Dom__HtmlElement.ofElement(elem);
        if (elem$1 !== undefined) {
          var elemStyle = Caml_option.valFromOption(elem$1).style;
          return List.fold_left((function (param, param$1) {
                        elemStyle.removeProperty(param$1[0]);
                      }), undefined, x._0);
        }
        throw {
              RE_EXN_ID: "Failure",
              _1: "Expected htmlelement in patchVNodesOnElems_PropertiesApply_Remove",
              Error: new Error()
            };
    
  }
}

function patchVNodesOnElemsPropertiesApplyRemoveAdd(callbacks, elem, idx, oldProp, newProp) {
  patchVNodesOnElemsPropertiesApplyRemove(callbacks, elem, idx, oldProp);
  patchVNodesOnElemsPropertiesApplyAdd(callbacks, elem, idx, newProp);
}

function patchVNodesOnElemsPropertiesApplyMutate(_callbacks, elem, _idx, oldProp, x) {
  if (typeof x === "number") {
    throw {
          RE_EXN_ID: "Failure",
          _1: "This should never be called as all entries through NoProp are gated.",
          Error: new Error()
        };
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        elem[x._0] = x._1;
        return ;
    case /* Attribute */1 :
        elem.setAttributeNS(x._0, x._1, x._2);
        return ;
    case /* Data */2 :
        console.log([
              "TODO:  Mutate Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Mutate Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        throw {
              RE_EXN_ID: "Failure",
              _1: "This will never be called because it is gated",
              Error: new Error()
            };
    case /* Style */4 :
        var elem$1 = Webapi__Dom__HtmlElement.ofElement(elem);
        if (elem$1 !== undefined) {
          var elemStyle = Caml_option.valFromOption(elem$1).style;
          if (typeof oldProp === "number") {
            throw {
                  RE_EXN_ID: "Failure",
                  _1: "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!",
                  Error: new Error()
                };
          }
          if (oldProp.TAG === /* Style */4) {
            return List.fold_left2((function (param, param$1, param$2) {
                          var nv = param$2[1];
                          var nk = param$2[0];
                          var ok = param$1[0];
                          if (ok === nk) {
                            if (param$1[1] === nv) {
                              return ;
                            } else {
                              elemStyle.setProperty(nk, nv);
                              return ;
                            }
                          } else {
                            elemStyle.removeProperty(ok);
                            elemStyle.setProperty(nk, nv);
                            return ;
                          }
                        }), undefined, oldProp._0, x._0);
          }
          throw {
                RE_EXN_ID: "Failure",
                _1: "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!",
                Error: new Error()
              };
        } else {
          throw {
                RE_EXN_ID: "Failure",
                _1: "Expected htmlelement in patchVNodesOnElemsPropertiesApplyMutate",
                Error: new Error()
              };
        }
    
  }
}

function patchVNodesOnElemsPropertiesApply(callbacks, elem, _idx, _oldProperties, _newProperties) {
  while(true) {
    var newProperties = _newProperties;
    var oldProperties = _oldProperties;
    var idx = _idx;
    if (!oldProperties) {
      if (newProperties) {
        return false;
      } else {
        return true;
      }
    }
    var _oldProp = oldProperties.hd;
    if (!newProperties) {
      return false;
    }
    if (typeof _oldProp === "number") {
      if (typeof newProperties.hd === "number") {
        _newProperties = newProperties.tl;
        _oldProperties = oldProperties.tl;
        _idx = idx + 1 | 0;
        continue ;
      }
      
    } else {
      switch (_oldProp.TAG | 0) {
        case /* RawProp */0 :
            var newProp = newProperties.hd;
            if (typeof newProp !== "number" && newProp.TAG === /* RawProp */0) {
              if (_oldProp._0 === newProp._0 && _oldProp._1 === newProp._1) {
                
              } else {
                patchVNodesOnElemsPropertiesApplyMutate(callbacks, elem, idx, _oldProp, newProp);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Attribute */1 :
            var newProp$1 = newProperties.hd;
            if (typeof newProp$1 !== "number" && newProp$1.TAG === /* Attribute */1) {
              if (_oldProp._0 === newProp$1._0 && _oldProp._1 === newProp$1._1 && _oldProp._2 === newProp$1._2) {
                
              } else {
                patchVNodesOnElemsPropertiesApplyMutate(callbacks, elem, idx, _oldProp, newProp$1);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Data */2 :
            var newProp$2 = newProperties.hd;
            if (typeof newProp$2 !== "number" && newProp$2.TAG === /* Data */2) {
              if (_oldProp._0 === newProp$2._0 && _oldProp._1 === newProp$2._1) {
                
              } else {
                patchVNodesOnElemsPropertiesApplyMutate(callbacks, elem, idx, _oldProp, newProp$2);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Event */3 :
            var _newProp = newProperties.hd;
            if (typeof _newProp !== "number" && _newProp.TAG === /* Event */3) {
              eventHandlerMutate(callbacks, elem, _oldProp._0, _newProp._0, _oldProp._1, _newProp._1, _oldProp._2, _newProp._2);
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Style */4 :
            var newProp$3 = newProperties.hd;
            if (typeof newProp$3 !== "number" && newProp$3.TAG === /* Style */4) {
              if (Caml_obj.equal(_oldProp._0, newProp$3._0)) {
                
              } else {
                patchVNodesOnElemsPropertiesApplyMutate(callbacks, elem, idx, _oldProp, newProp$3);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        
      }
    }
    patchVNodesOnElemsPropertiesApplyRemoveAdd(callbacks, elem, idx, _oldProp, newProperties.hd);
    _newProperties = newProperties.tl;
    _oldProperties = oldProperties.tl;
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesOnElemsProperties(callbacks, elem, oldProperties, newProperties) {
  return patchVNodesOnElemsPropertiesApply(callbacks, elem, 0, oldProperties, newProperties);
}

function genEmptyProps(length) {
  var _lst = /* [] */0;
  var _x = length;
  while(true) {
    var x = _x;
    var lst = _lst;
    if (x === 0) {
      return lst;
    }
    _x = x - 1 | 0;
    _lst = {
      hd: /* NoProp */0,
      tl: lst
    };
    continue ;
  };
}

function mapEmptyProps(props) {
  return List.map((function (param) {
                return /* NoProp */0;
              }), props);
}

function patchVNodesOnElemsReplaceNode(callbacks, elem, elems, idx, x) {
  if (x.TAG === /* Node */2) {
    var newProperties = x._4;
    var oldChild = nodeAt(idx, elems);
    var newChild = createElementNsOptional(x._0, x._1);
    patchVNodesOnElemsProperties(callbacks, newChild, List.map((function (param) {
                return /* NoProp */0;
              }), newProperties), newProperties);
    var childChildren = newChild.childNodes;
    patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, x._5);
    elem.insertBefore(newChild, oldChild);
    elem.removeChild(oldChild);
    return ;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Node replacement should never be passed anything but a node itself",
        Error: new Error()
      };
}

function patchVNodesOnElemsCreateElement(_callbacks, _x) {
  while(true) {
    var x = _x;
    var callbacks = _callbacks;
    switch (x.TAG | 0) {
      case /* CommentNode */0 :
          return document.createComment(x._0);
      case /* Text */1 :
          return document.createTextNode(x._0);
      case /* Node */2 :
          var newProperties = x._4;
          var newChild = createElementNsOptional(x._0, x._1);
          var match = patchVNodesOnElemsProperties(callbacks, newChild, List.map((function (param) {
                      return /* NoProp */0;
                    }), newProperties), newProperties);
          if (match) {
            var childChildren = newChild.childNodes;
            patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, x._5);
            return newChild;
          }
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "vdom.res",
                  484,
                  10
                ],
                Error: new Error()
              };
      case /* LazyGen */3 :
          var vdom = Curry._1(x._1, undefined);
          x._2.contents = vdom;
          _x = vdom;
          continue ;
      case /* Tagger */4 :
          _x = x._1;
          _callbacks = Curry._1(x._0, callbacks);
          continue ;
      
    }
  };
}

function patchVNodesOnElemsMutateNode(callbacks, elem, elems, idx, oldNode, newNode) {
  if (oldNode.TAG === /* Node */2) {
    if (newNode.TAG === /* Node */2) {
      if (oldNode._3 !== newNode._3 || oldNode._1 !== newNode._1) {
        return patchVNodesOnElemsReplaceNode(callbacks, elem, elems, idx, newNode);
      }
      var child = nodeAt(idx, elems);
      var childElement = Webapi__Dom__Element.ofNode(child);
      if (childElement !== undefined) {
        var childChildren = child.childNodes;
        if (patchVNodesOnElemsProperties(callbacks, Caml_option.valFromOption(childElement), oldNode._4, newNode._4)) {
          
        } else {
          console.log("VDom:  Failed swapping properties because the property list length changed, use `noProp` to swap properties instead, not by altering the list structure.  This is a massive inefficiency until this issue is resolved.");
          patchVNodesOnElemsReplaceNode(callbacks, elem, elems, idx, newNode);
        }
        return patchVNodesOnElems(callbacks, child, childChildren, 0, oldNode._5, newNode._5);
      }
      throw {
            RE_EXN_ID: "Failure",
            _1: "Expected element in patchVNodesOnElems_MutateNode",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "Non-node passed to patchVNodesOnElemsMutateNode",
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Non-node passed to patchVNodesOnElemsMutateNode",
        Error: new Error()
      };
}

function patchVNodesOnElems(callbacks, elem, elems, _idx, _oldVNodes, _newVNodes) {
  while(true) {
    var newVNodes = _newVNodes;
    var oldVNodes = _oldVNodes;
    var idx = _idx;
    if (oldVNodes) {
      var oldNode = oldVNodes.hd;
      switch (oldNode.TAG | 0) {
        case /* CommentNode */0 :
            if (newVNodes) {
              var newS = newVNodes.hd;
              if (newS.TAG === /* CommentNode */0 && oldNode._0 === newS._0) {
                _newVNodes = newVNodes.tl;
                _oldVNodes = oldVNodes.tl;
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Text */1 :
            if (newVNodes) {
              var newText = newVNodes.hd;
              if (newText.TAG === /* Text */1) {
                var newText$1 = newText._0;
                if (oldNode._0 !== newText$1) {
                  var child = nodeAt(idx, elems);
                  child.nodeValue = newText$1;
                }
                _newVNodes = newVNodes.tl;
                _oldVNodes = oldVNodes.tl;
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Node */2 :
            if (newVNodes) {
              var newNode = newVNodes.hd;
              if (newNode.TAG === /* Node */2) {
                var newRest = newVNodes.tl;
                var newKey = newNode._2;
                var newTagName = newNode._1;
                var newNamespace = newNode._0;
                var oldRest = oldVNodes.tl;
                var oldKey = oldNode._2;
                var oldTagName = oldNode._1;
                var oldNamespace = oldNode._0;
                if (oldKey === newKey && oldKey !== "") {
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                if (oldKey === "" || newKey === "") {
                  patchVNodesOnElemsMutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit = 0;
                var exit$1 = 0;
                if (oldRest) {
                  var match = oldRest.hd;
                  if (match.TAG === /* Node */2) {
                    var olderRest = oldRest.tl;
                    var olderKey = match._2;
                    var olderTagName = match._1;
                    var olderNamespace = match._0;
                    var exit$2 = 0;
                    if (newRest) {
                      var match$1 = newRest.hd;
                      if (match$1.TAG === /* Node */2) {
                        if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey && oldNamespace === match$1._0 && oldTagName === match$1._1 && oldKey === match$1._2) {
                          var firstChild = nodeAt(idx, elems);
                          var secondChild = nodeAt(idx + 1 | 0, elems);
                          elem.removeChild(secondChild);
                          elem.insertBefore(secondChild, firstChild);
                          _newVNodes = newRest.tl;
                          _oldVNodes = olderRest;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$2 = 4;
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                    if (exit$2 === 4) {
                      if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey) {
                        var oldChild = nodeAt(idx, elems);
                        elem.removeChild(oldChild);
                        _newVNodes = newRest;
                        _oldVNodes = olderRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$1 = 3;
                    }
                    
                  } else {
                    exit$1 = 3;
                  }
                } else {
                  exit$1 = 3;
                }
                if (exit$1 === 3) {
                  if (newRest) {
                    var match$2 = newRest.hd;
                    if (match$2.TAG === /* Node */2) {
                      if (oldNamespace === match$2._0 && oldTagName === match$2._1 && oldKey === match$2._2) {
                        var oldChild$1 = nodeAt(idx, elems);
                        var newChild = patchVNodesOnElemsCreateElement(callbacks, newNode);
                        elem.insertBefore(newChild, oldChild$1);
                        _newVNodes = newRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit = 2;
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                }
                if (exit === 2) {
                  patchVNodesOnElemsMutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                
              }
              
            }
            break;
        case /* LazyGen */3 :
            if (newVNodes) {
              var match$3 = newVNodes.hd;
              if (match$3.TAG === /* LazyGen */3) {
                var newRest$1 = newVNodes.tl;
                var newCache = match$3._2;
                var newGen = match$3._1;
                var newKey$1 = match$3._0;
                var oldRest$1 = oldVNodes.tl;
                var oldCache = oldNode._2;
                var oldKey$1 = oldNode._0;
                if (oldKey$1 === newKey$1) {
                  newCache.contents = oldCache.contents;
                  _newVNodes = newRest$1;
                  _oldVNodes = oldRest$1;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit$3 = 0;
                var exit$4 = 0;
                if (oldRest$1) {
                  var match$4 = oldRest$1.hd;
                  if (match$4.TAG === /* LazyGen */3) {
                    var olderRest$1 = oldRest$1.tl;
                    var olderKey$1 = match$4._0;
                    var exit$5 = 0;
                    if (newRest$1) {
                      var match$5 = newRest$1.hd;
                      if (match$5.TAG === /* LazyGen */3) {
                        if (olderKey$1 === newKey$1 && oldKey$1 === match$5._0) {
                          var firstChild$1 = nodeAt(idx, elems);
                          var secondChild$1 = nodeAt(idx + 1 | 0, elems);
                          elem.removeChild(secondChild$1);
                          elem.insertBefore(secondChild$1, firstChild$1);
                          _newVNodes = newRest$1.tl;
                          _oldVNodes = olderRest$1;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$5 = 4;
                      } else {
                        exit$5 = 4;
                      }
                    } else {
                      exit$5 = 4;
                    }
                    if (exit$5 === 4) {
                      if (olderKey$1 === newKey$1) {
                        var oldChild$2 = nodeAt(idx, elems);
                        elem.removeChild(oldChild$2);
                        var oldVdom = match$4._2.contents;
                        newCache.contents = oldVdom;
                        _newVNodes = newRest$1;
                        _oldVNodes = olderRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$4 = 3;
                    }
                    
                  } else {
                    exit$4 = 3;
                  }
                } else {
                  exit$4 = 3;
                }
                if (exit$4 === 3) {
                  if (newRest$1) {
                    var match$6 = newRest$1.hd;
                    if (match$6.TAG === /* LazyGen */3) {
                      if (match$6._0 === oldKey$1) {
                        var oldChild$3 = nodeAt(idx, elems);
                        var newVdom = Curry._1(newGen, undefined);
                        newCache.contents = newVdom;
                        var newChild$1 = patchVNodesOnElemsCreateElement(callbacks, newVdom);
                        elem.insertBefore(newChild$1, oldChild$3);
                        _newVNodes = newRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$3 = 2;
                    } else {
                      exit$3 = 2;
                    }
                  } else {
                    exit$3 = 2;
                  }
                }
                if (exit$3 === 2) {
                  var oldVdom$1 = oldCache.contents;
                  var newVdom$1 = Curry._1(newGen, undefined);
                  newCache.contents = newVdom$1;
                  _newVNodes = {
                    hd: newVdom$1,
                    tl: newRest$1
                  };
                  _oldVNodes = {
                    hd: oldVdom$1,
                    tl: oldRest$1
                  };
                  continue ;
                }
                
              }
              
            }
            break;
        case /* Tagger */4 :
            _oldVNodes = {
              hd: oldNode._1,
              tl: oldVNodes.tl
            };
            continue ;
        
      }
      var oldRest$2 = oldVNodes.tl;
      if (newVNodes) {
        var newNode$1 = newVNodes.hd;
        if (newNode$1.TAG === /* Tagger */4) {
          patchVNodesOnElems(Curry._1(newNode$1._0, callbacks), elem, elems, idx, {
                hd: oldNode,
                tl: /* [] */0
              }, {
                hd: newNode$1._1,
                tl: /* [] */0
              });
          _newVNodes = newVNodes.tl;
          _oldVNodes = oldRest$2;
          _idx = idx + 1 | 0;
          continue ;
        }
        var oldChild$4 = nodeAt(idx, elems);
        var newChild$2 = patchVNodesOnElemsCreateElement(callbacks, newNode$1);
        elem.insertBefore(newChild$2, oldChild$4);
        elem.removeChild(oldChild$4);
        _newVNodes = newVNodes.tl;
        _oldVNodes = oldRest$2;
        _idx = idx + 1 | 0;
        continue ;
      }
      var child$1 = nodeAt(idx, elems);
      elem.removeChild(child$1);
      _newVNodes = /* [] */0;
      _oldVNodes = oldRest$2;
      continue ;
    }
    if (!newVNodes) {
      return ;
    }
    var newChild$3 = patchVNodesOnElemsCreateElement(callbacks, newVNodes.hd);
    elem.appendChild(newChild$3);
    _newVNodes = newVNodes.tl;
    _oldVNodes = /* [] */0;
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesIntoElement(callbacks, elem, oldVNodes, newVNodes) {
  var elems = elem.childNodes;
  patchVNodesOnElems(callbacks, elem, elems, 0, oldVNodes, newVNodes);
  return newVNodes;
}

function patchVNodeIntoElement(callbacks, elem, oldVNode, newVNode) {
  return patchVNodesIntoElement(callbacks, elem, {
              hd: oldVNode,
              tl: /* [] */0
            }, {
              hd: newVNode,
              tl: /* [] */0
            });
}

function wrapCallbacksOn(func, x) {
  if (typeof x === "number") {
    return /* Render */0;
  } else if (x.TAG === /* AddRenderMsg */0) {
    return {
            TAG: /* AddRenderMsg */0,
            _0: Curry._1(func, x._0)
          };
  } else {
    return {
            TAG: /* RemoveRenderMsg */1,
            _0: Curry._1(func, x._0)
          };
  }
}

function wrapCallbacks(func, callbacks) {
  return {
          contents: {
            enqueue: (function (msg) {
                Curry._1(callbacks.contents.enqueue, Curry._1(func, msg));
              }),
            on: (function (smsg) {
                Curry._1(callbacks.contents.on, wrapCallbacksOn(func, smsg));
              })
          }
        };
}

function map(func, vdom) {
  var tagger = function (param) {
    return wrapCallbacks(func, param);
  };
  return {
          TAG: /* Tagger */4,
          _0: tagger,
          _1: vdom
        };
}

var noProp = /* NoProp */0;

exports.noNode = noNode;
exports.comment = comment;
exports.text = text;
exports.fullnode = fullnode;
exports.node = node;
exports.lazyGen = lazyGen;
exports.noProp = noProp;
exports.prop = prop;
exports.onCB = onCB;
exports.onMsg = onMsg;
exports.attribute = attribute;
exports.data = data;
exports.style = style;
exports.styles = styles;
exports.renderToHtmlString = renderToHtmlString;
exports.emptyEventHandler = emptyEventHandler;
exports.emptyEventCB = emptyEventCB;
exports.eventHandler = eventHandler;
exports.eventHandlerGetCB = eventHandlerGetCB;
exports.compareEventHandlerTypes = compareEventHandlerTypes;
exports.eventHandlerRegister = eventHandlerRegister;
exports.eventHandlerUnregister = eventHandlerUnregister;
exports.eventHandlerMutate = eventHandlerMutate;
exports.patchVNodesOnElemsPropertiesApplyAdd = patchVNodesOnElemsPropertiesApplyAdd;
exports.patchVNodesOnElemsPropertiesApplyRemove = patchVNodesOnElemsPropertiesApplyRemove;
exports.patchVNodesOnElemsPropertiesApplyRemoveAdd = patchVNodesOnElemsPropertiesApplyRemoveAdd;
exports.patchVNodesOnElemsPropertiesApplyMutate = patchVNodesOnElemsPropertiesApplyMutate;
exports.patchVNodesOnElemsPropertiesApply = patchVNodesOnElemsPropertiesApply;
exports.patchVNodesOnElemsProperties = patchVNodesOnElemsProperties;
exports.genEmptyProps = genEmptyProps;
exports.mapEmptyProps = mapEmptyProps;
exports.patchVNodesOnElemsReplaceNode = patchVNodesOnElemsReplaceNode;
exports.patchVNodesOnElemsCreateElement = patchVNodesOnElemsCreateElement;
exports.patchVNodesOnElemsMutateNode = patchVNodesOnElemsMutateNode;
exports.patchVNodesOnElems = patchVNodesOnElems;
exports.patchVNodesIntoElement = patchVNodesIntoElement;
exports.patchVNodeIntoElement = patchVNodeIntoElement;
exports.wrapCallbacksOn = wrapCallbacksOn;
exports.wrapCallbacks = wrapCallbacks;
exports.map = map;
/* Webapi__Dom__Element Not a pure module */

},{"rescript-webapi/src/Webapi/Dom/Webapi__Dom__Element.bs.js":9,"rescript-webapi/src/Webapi/Dom/Webapi__Dom__HtmlElement.bs.js":12,"rescript/lib/js/belt_List.js":20,"rescript/lib/js/belt_Option.js":22,"rescript/lib/js/caml_obj.js":32,"rescript/lib/js/caml_option.js":33,"rescript/lib/js/curry.js":37,"rescript/lib/js/list.js":43}],8:[function(require,module,exports){
'use strict';


function Impl(T) {
  return {};
}

exports.Impl = Impl;
/* No side effect */

},{}],9:[function(require,module,exports){
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Webapi__Dom__Node = require("./Webapi__Dom__Node.bs.js");
var Webapi__Dom__Types = require("./Webapi__Dom__Types.bs.js");
var Webapi__Dom__Slotable = require("./Webapi__Dom__Slotable.bs.js");
var Webapi__Dom__ChildNode = require("./Webapi__Dom__ChildNode.bs.js");
var Webapi__Dom__ParentNode = require("./Webapi__Dom__ParentNode.bs.js");
var Webapi__Dom__EventTarget = require("./Webapi__Dom__EventTarget.bs.js");
var Webapi__Dom__GlobalEventHandlers = require("./Webapi__Dom__GlobalEventHandlers.bs.js");
var Webapi__Dom__NonDocumentTypeChildNode = require("./Webapi__Dom__NonDocumentTypeChildNode.bs.js");

function ofNode(node) {
  if (Webapi__Dom__Node.nodeType(node) === /* Element */0) {
    return Caml_option.some(node);
  }
  
}

var asHtmlElement = (function(element) {
      if ((window.constructor.name !== undefined && /^HTML\w*Element$/.test(element.constructor.name))
          || (/^\[object HTML\w*Element\]$/.test(element.constructor.toString()))) {
        return element;
      }
    });

function Impl(T) {
  var insertAdjacentElement = function (self, position, element) {
    self.insertAdjacentElement(Webapi__Dom__Types.encodeInsertPosition(position), element);
  };
  var insertAdjacentHTML = function (self, position, text) {
    self.insertAdjacentHTML(Webapi__Dom__Types.encodeInsertPosition(position), text);
  };
  var insertAdjacentText = function (self, position, text) {
    self.insertAdjacentText(Webapi__Dom__Types.encodeInsertPosition(position), text);
  };
  return {
          asHtmlElement: asHtmlElement,
          ofNode: ofNode,
          insertAdjacentElement: insertAdjacentElement,
          insertAdjacentHTML: insertAdjacentHTML,
          insertAdjacentText: insertAdjacentText
        };
}

var include = Webapi__Dom__Node.Impl({});

Webapi__Dom__EventTarget.Impl({});

Webapi__Dom__GlobalEventHandlers.Impl({});

Webapi__Dom__ParentNode.Impl({});

Webapi__Dom__NonDocumentTypeChildNode.Impl({});

Webapi__Dom__ChildNode.Impl({});

Webapi__Dom__Slotable.Impl({});

function insertAdjacentElement(self, position, element) {
  self.insertAdjacentElement(Webapi__Dom__Types.encodeInsertPosition(position), element);
}

function insertAdjacentHTML(self, position, text) {
  self.insertAdjacentHTML(Webapi__Dom__Types.encodeInsertPosition(position), text);
}

function insertAdjacentText(self, position, text) {
  self.insertAdjacentText(Webapi__Dom__Types.encodeInsertPosition(position), text);
}

var nodeType = include.nodeType;

exports.Impl = Impl;
exports.nodeType = nodeType;
exports.asHtmlElement = asHtmlElement;
exports.ofNode = ofNode;
exports.insertAdjacentElement = insertAdjacentElement;
exports.insertAdjacentHTML = insertAdjacentHTML;
exports.insertAdjacentText = insertAdjacentText;
/* include Not a pure module */

},{"./Webapi__Dom__ChildNode.bs.js":8,"./Webapi__Dom__EventTarget.bs.js":10,"./Webapi__Dom__GlobalEventHandlers.bs.js":11,"./Webapi__Dom__Node.bs.js":13,"./Webapi__Dom__NonDocumentTypeChildNode.bs.js":14,"./Webapi__Dom__ParentNode.bs.js":15,"./Webapi__Dom__Slotable.bs.js":16,"./Webapi__Dom__Types.bs.js":17,"rescript/lib/js/caml_option.js":33}],10:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],11:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],12:[function(require,module,exports){
'use strict';

var Webapi__Dom__Node = require("./Webapi__Dom__Node.bs.js");
var Webapi__Dom__Types = require("./Webapi__Dom__Types.bs.js");
var Webapi__Dom__Element = require("./Webapi__Dom__Element.bs.js");
var Webapi__Dom__EventTarget = require("./Webapi__Dom__EventTarget.bs.js");
var Webapi__Dom__GlobalEventHandlers = require("./Webapi__Dom__GlobalEventHandlers.bs.js");

function Impl(T) {
  var contentEditable = function (self) {
    return Webapi__Dom__Types.decodeContentEditable(self.contentEditable);
  };
  var setContentEditable = function (self, value) {
    self.contentEditable = Webapi__Dom__Types.encodeContentEditable(value);
  };
  var dir = function (self) {
    return Webapi__Dom__Types.decodeDir(self.dir);
  };
  var setDir = function (self, value) {
    self.dir = Webapi__Dom__Types.encodeDir(value);
  };
  return {
          ofElement: Webapi__Dom__Element.asHtmlElement,
          contentEditable: contentEditable,
          setContentEditable: setContentEditable,
          dir: dir,
          setDir: setDir
        };
}

var include = Webapi__Dom__Node.Impl({});

Webapi__Dom__EventTarget.Impl({});

Webapi__Dom__GlobalEventHandlers.Impl({});

var include$1 = Webapi__Dom__Element.Impl({});

function contentEditable(self) {
  return Webapi__Dom__Types.decodeContentEditable(self.contentEditable);
}

function setContentEditable(self, value) {
  self.contentEditable = Webapi__Dom__Types.encodeContentEditable(value);
}

function dir(self) {
  return Webapi__Dom__Types.decodeDir(self.dir);
}

function setDir(self, value) {
  self.dir = Webapi__Dom__Types.encodeDir(value);
}

var nodeType = include.nodeType;

var asHtmlElement = include$1.asHtmlElement;

var ofNode = include$1.ofNode;

var insertAdjacentElement = include$1.insertAdjacentElement;

var insertAdjacentHTML = include$1.insertAdjacentHTML;

var insertAdjacentText = include$1.insertAdjacentText;

var ofElement = Webapi__Dom__Element.asHtmlElement;

exports.Impl = Impl;
exports.nodeType = nodeType;
exports.asHtmlElement = asHtmlElement;
exports.ofNode = ofNode;
exports.insertAdjacentElement = insertAdjacentElement;
exports.insertAdjacentHTML = insertAdjacentHTML;
exports.insertAdjacentText = insertAdjacentText;
exports.ofElement = ofElement;
exports.contentEditable = contentEditable;
exports.setContentEditable = setContentEditable;
exports.dir = dir;
exports.setDir = setDir;
/* include Not a pure module */

},{"./Webapi__Dom__Element.bs.js":9,"./Webapi__Dom__EventTarget.bs.js":10,"./Webapi__Dom__GlobalEventHandlers.bs.js":11,"./Webapi__Dom__Node.bs.js":13,"./Webapi__Dom__Types.bs.js":17}],13:[function(require,module,exports){
'use strict';

var Webapi__Dom__Types = require("./Webapi__Dom__Types.bs.js");
var Webapi__Dom__EventTarget = require("./Webapi__Dom__EventTarget.bs.js");

function Impl(T) {
  var nodeType = function (self) {
    return Webapi__Dom__Types.decodeNodeType(self.nodeType);
  };
  return {
          nodeType: nodeType
        };
}

Webapi__Dom__EventTarget.Impl({});

function nodeType(self) {
  return Webapi__Dom__Types.decodeNodeType(self.nodeType);
}

exports.Impl = Impl;
exports.nodeType = nodeType;
/*  Not a pure module */

},{"./Webapi__Dom__EventTarget.bs.js":10,"./Webapi__Dom__Types.bs.js":17}],14:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],15:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],16:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],17:[function(require,module,exports){
'use strict';


function encodeCompareHow(x) {
  return x;
}

function decodeCompareResult(x) {
  if ((x + 1 >>> 0) > 2) {
    return /* Unknown */3;
  } else {
    return x + 1 | 0;
  }
}

function decodeCompatMode(x) {
  switch (x) {
    case "BackCompat" :
        return /* BackCompat */0;
    case "CSS1Compat" :
        return /* CSS1Compat */1;
    default:
      return /* Unknown */2;
  }
}

function encodeContentEditable(x) {
  switch (x) {
    case /* True */0 :
        return "true";
    case /* False */1 :
        return "false";
    case /* Inherit */2 :
        return "inherit";
    case /* Unknown */3 :
        return "";
    
  }
}

function decodeContentEditable(x) {
  switch (x) {
    case "false" :
        return /* False */1;
    case "inherit" :
        return /* Inherit */2;
    case "true" :
        return /* True */0;
    default:
      return /* Unknown */3;
  }
}

function decodeDeltaMode(x) {
  if (x > 2 || x < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "invalid deltaMode",
          Error: new Error()
        };
  }
  return x;
}

function encodeDesignMode(x) {
  switch (x) {
    case /* On */0 :
        return "on";
    case /* Off */1 :
        return "off";
    case /* Unknown */2 :
        return "";
    
  }
}

function decodeDesignMode(x) {
  switch (x) {
    case "off" :
        return /* Off */1;
    case "on" :
        return /* On */0;
    default:
      return /* Unknown */2;
  }
}

function encodeDir(x) {
  switch (x) {
    case /* Ltr */0 :
        return "ltr";
    case /* Rtl */1 :
        return "rtl";
    case /* Unknown */2 :
        return "";
    
  }
}

function decodeDir(x) {
  switch (x) {
    case "ltr" :
        return /* Ltr */0;
    case "rtl" :
        return /* Rtl */1;
    default:
      return /* Unknown */2;
  }
}

function decode(x) {
  if (x > 3 || x < 0) {
    return /* Unknown */4;
  } else {
    return x;
  }
}

var EventPhase = {
  decode: decode
};

function encodeFilterAction(x) {
  return x + 1 | 0;
}

function encodeInsertPosition(x) {
  switch (x) {
    case /* BeforeBegin */0 :
        return "beforebegin";
    case /* AfterBegin */1 :
        return "afterbegin";
    case /* BeforeEnd */2 :
        return "beforeend";
    case /* AfterEnd */3 :
        return "afterend";
    
  }
}

function encodeModifierKey(x) {
  switch (x) {
    case /* Alt */0 :
        return "Alt";
    case /* AltGraph */1 :
        return "AltGraph";
    case /* CapsLock */2 :
        return "CapsLock";
    case /* Control */3 :
        return "Control";
    case /* Fn */4 :
        return "Fn";
    case /* FnLock */5 :
        return "FnLock";
    case /* Hyper */6 :
        return "Hyper";
    case /* Meta */7 :
        return "Meta";
    case /* NumLock */8 :
        return "NumLock";
    case /* ScrollLock */9 :
        return "ScrollLock";
    case /* Shift */10 :
        return "Shift";
    case /* Super */11 :
        return "Super";
    case /* Symbol */12 :
        return "Symbol";
    case /* SymbolLock */13 :
        return "SymbolLock";
    
  }
}

function decodeNodeType(x) {
  if (x > 12 || x < 1) {
    return /* Unknown */12;
  } else {
    return x - 1 | 0;
  }
}

function decodePointerType(x) {
  switch (x) {
    case "mouse" :
        return /* Mouse */0;
    case "pen" :
        return /* Pen */1;
    case "touch|" :
        return /* Touch */2;
    default:
      return /* Unknown */3;
  }
}

function decodeReadyState(x) {
  switch (x) {
    case "complete" :
        return /* Complete */2;
    case "interactive" :
        return /* Interactive */1;
    case "loading" :
        return /* Loading */0;
    default:
      return /* Unknown */3;
  }
}

function decodeShadowRootMode(x) {
  switch (x) {
    case "closed" :
        return /* Closed */1;
    case "open" :
        return /* Open */0;
    default:
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "Unknown shadowRootMode",
            Error: new Error()
          };
  }
}

function decodeVisibilityState(x) {
  switch (x) {
    case "hidden" :
        return /* Hidden */1;
    case "prerender" :
        return /* Prerender */2;
    case "unloaded" :
        return /* Unloaded */3;
    case "visible" :
        return /* Visible */0;
    default:
      return /* Unknown */4;
  }
}

function many(x) {
  if (x) {
    return x.hd | many(x.tl);
  } else {
    return 0;
  }
}

var WhatToShow = {
  _All: -1,
  _Element: 1,
  _Attribute: 2,
  _Text: 4,
  _CDATASection: 8,
  _EntityReference: 16,
  _Entity: 32,
  _ProcessingInstruction: 64,
  _Comment: 128,
  _Document: 256,
  _DocumentType: 512,
  _DocumentFragment: 1024,
  _Notation: 2048,
  many: many
};

exports.encodeCompareHow = encodeCompareHow;
exports.decodeCompareResult = decodeCompareResult;
exports.decodeCompatMode = decodeCompatMode;
exports.encodeContentEditable = encodeContentEditable;
exports.decodeContentEditable = decodeContentEditable;
exports.decodeDeltaMode = decodeDeltaMode;
exports.encodeDesignMode = encodeDesignMode;
exports.decodeDesignMode = decodeDesignMode;
exports.encodeDir = encodeDir;
exports.decodeDir = decodeDir;
exports.EventPhase = EventPhase;
exports.encodeFilterAction = encodeFilterAction;
exports.encodeInsertPosition = encodeInsertPosition;
exports.encodeModifierKey = encodeModifierKey;
exports.decodeNodeType = decodeNodeType;
exports.decodePointerType = decodePointerType;
exports.decodeReadyState = decodeReadyState;
exports.decodeShadowRootMode = decodeShadowRootMode;
exports.decodeVisibilityState = decodeVisibilityState;
exports.WhatToShow = WhatToShow;
/* No side effect */

},{}],18:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_obj = require("./caml_obj.js");
var Caml_array = require("./caml_array.js");
var Caml_exceptions = require("./caml_exceptions.js");
var Caml_js_exceptions = require("./caml_js_exceptions.js");

var make_float = Caml_array.make_float;

var Floatarray = {};

function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.init",
          Error: new Error()
        };
  }
  var res = Caml_array.make(l, Curry._1(f, 0));
  for(var i = 1; i < l; ++i){
    res[i] = Curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, init) {
  var res = Caml_array.make(sx, []);
  for(var x = 0; x < sx; ++x){
    res[x] = Caml_array.make(sy, init);
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l === 0) {
    return [];
  } else {
    return Caml_array.sub(a, 0, l);
  }
}

function append(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return Caml_array.sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.sub",
          Error: new Error()
        };
  }
  return Caml_array.sub(a, ofs, len);
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.fill",
          Error: new Error()
        };
  }
  for(var i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    a[i] = v;
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.blit",
          Error: new Error()
        };
  }
  Caml_array.blit(a1, ofs1, a2, ofs2, len);
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.iter2: arrays must have the same length",
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = Caml_array.make(l, Curry._1(f, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.map2: arrays must have the same length",
          Error: new Error()
        };
  }
  if (la === 0) {
    return [];
  }
  var r = Caml_array.make(la, Curry._2(f, a[0], b[0]));
  for(var i = 1; i < la; ++i){
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = Caml_array.make(l, Curry._2(f, 0, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function of_list(l) {
  if (!l) {
    return [];
  }
  var a = Caml_array.make(list_length(0, l), l.hd);
  var _i = 1;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    a[i] = param.hd;
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function memq(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

var Bottom = /* @__PURE__ */Caml_exceptions.create("Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          RE_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return Caml_array.set(a, i$2._1, e);
      }
      throw i$2;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw i$2;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "array.ml",
                236,
                4
              ],
              Error: new Error()
            };
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Caml_array.get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Caml_array.get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Caml_array.set(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = Caml_array.get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = Caml_array.make(l2, Caml_array.get(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

var create_matrix = make_matrix;

var concat = Caml_array.concat;

var fast_sort = stable_sort;

exports.make_float = make_float;
exports.init = init;
exports.make_matrix = make_matrix;
exports.create_matrix = create_matrix;
exports.append = append;
exports.concat = concat;
exports.sub = sub;
exports.copy = copy;
exports.fill = fill;
exports.blit = blit;
exports.to_list = to_list;
exports.of_list = of_list;
exports.iter = iter;
exports.iteri = iteri;
exports.map = map;
exports.mapi = mapi;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.iter2 = iter2;
exports.map2 = map2;
exports.for_all = for_all;
exports.exists = exists;
exports.mem = mem;
exports.memq = memq;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.fast_sort = fast_sort;
exports.Floatarray = Floatarray;
/* No side effect */

},{"./caml_array.js":27,"./caml_exceptions.js":28,"./caml_js_exceptions.js":31,"./caml_obj.js":32,"./curry.js":37}],19:[function(require,module,exports){
'use strict';

var Caml = require("./caml.js");
var Curry = require("./curry.js");
var Js_math = require("./js_math.js");
var Caml_option = require("./caml_option.js");

function get(arr, i) {
  if (i >= 0 && i < arr.length) {
    return Caml_option.some(arr[i]);
  }
  
}

function getExn(arr, i) {
  if (!(i >= 0 && i < arr.length)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "belt_Array.ml",
            35,
            2
          ],
          Error: new Error()
        };
  }
  return arr[i];
}

function set(arr, i, v) {
  if (i >= 0 && i < arr.length) {
    arr[i] = v;
    return true;
  } else {
    return false;
  }
}

function setExn(arr, i, v) {
  if (!(i >= 0 && i < arr.length)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "belt_Array.ml",
            45,
            2
          ],
          Error: new Error()
        };
  }
  arr[i] = v;
}

function swapUnsafe(xs, i, j) {
  var tmp = xs[i];
  xs[i] = xs[j];
  xs[j] = tmp;
}

function shuffleInPlace(xs) {
  var len = xs.length;
  for(var i = 0; i < len; ++i){
    swapUnsafe(xs, i, Js_math.random_int(i, len));
  }
}

function shuffle(xs) {
  var result = xs.slice(0);
  shuffleInPlace(result);
  return result;
}

function reverseInPlace(xs) {
  var len = xs.length;
  var ofs = 0;
  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){
    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);
  }
}

function reverse(xs) {
  var len = xs.length;
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = xs[(len - 1 | 0) - i | 0];
  }
  return result;
}

function make(l, f) {
  if (l <= 0) {
    return [];
  }
  var res = new Array(l);
  for(var i = 0; i < l; ++i){
    res[i] = f;
  }
  return res;
}

function makeByU(l, f) {
  if (l <= 0) {
    return [];
  }
  var res = new Array(l);
  for(var i = 0; i < l; ++i){
    res[i] = f(i);
  }
  return res;
}

function makeBy(l, f) {
  return makeByU(l, Curry.__1(f));
}

function makeByAndShuffleU(l, f) {
  var u = makeByU(l, f);
  shuffleInPlace(u);
  return u;
}

function makeByAndShuffle(l, f) {
  return makeByAndShuffleU(l, Curry.__1(f));
}

function range(start, finish) {
  var cut = finish - start | 0;
  if (cut < 0) {
    return [];
  }
  var arr = new Array(cut + 1 | 0);
  for(var i = 0; i <= cut; ++i){
    arr[i] = start + i | 0;
  }
  return arr;
}

function rangeBy(start, finish, step) {
  var cut = finish - start | 0;
  if (cut < 0 || step <= 0) {
    return [];
  }
  var nb = (cut / step | 0) + 1 | 0;
  var arr = new Array(nb);
  var cur = start;
  for(var i = 0; i < nb; ++i){
    arr[i] = cur;
    cur = cur + step | 0;
  }
  return arr;
}

function zip(xs, ys) {
  var lenx = xs.length;
  var leny = ys.length;
  var len = lenx < leny ? lenx : leny;
  var s = new Array(len);
  for(var i = 0; i < len; ++i){
    s[i] = [
      xs[i],
      ys[i]
    ];
  }
  return s;
}

function zipByU(xs, ys, f) {
  var lenx = xs.length;
  var leny = ys.length;
  var len = lenx < leny ? lenx : leny;
  var s = new Array(len);
  for(var i = 0; i < len; ++i){
    s[i] = f(xs[i], ys[i]);
  }
  return s;
}

function zipBy(xs, ys, f) {
  return zipByU(xs, ys, Curry.__2(f));
}

function concat(a1, a2) {
  var l1 = a1.length;
  var l2 = a2.length;
  var a1a2 = new Array(l1 + l2 | 0);
  for(var i = 0; i < l1; ++i){
    a1a2[i] = a1[i];
  }
  for(var i$1 = 0; i$1 < l2; ++i$1){
    a1a2[l1 + i$1 | 0] = a2[i$1];
  }
  return a1a2;
}

function concatMany(arrs) {
  var lenArrs = arrs.length;
  var totalLen = 0;
  for(var i = 0; i < lenArrs; ++i){
    totalLen = totalLen + arrs[i].length | 0;
  }
  var result = new Array(totalLen);
  totalLen = 0;
  for(var j = 0; j < lenArrs; ++j){
    var cur = arrs[j];
    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){
      result[totalLen] = cur[k];
      totalLen = totalLen + 1 | 0;
    }
  }
  return result;
}

function slice(a, offset, len) {
  if (len <= 0) {
    return [];
  }
  var lena = a.length;
  var ofs = offset < 0 ? Caml.int_max(lena + offset | 0, 0) : offset;
  var hasLen = lena - ofs | 0;
  var copyLength = hasLen < len ? hasLen : len;
  if (copyLength <= 0) {
    return [];
  }
  var result = new Array(copyLength);
  for(var i = 0; i < copyLength; ++i){
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function sliceToEnd(a, offset) {
  var lena = a.length;
  var ofs = offset < 0 ? Caml.int_max(lena + offset | 0, 0) : offset;
  var len = lena > ofs ? lena - ofs | 0 : 0;
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = a[ofs + i | 0];
  }
  return result;
}

function fill(a, offset, len, v) {
  if (len <= 0) {
    return ;
  }
  var lena = a.length;
  var ofs = offset < 0 ? Caml.int_max(lena + offset | 0, 0) : offset;
  var hasLen = lena - ofs | 0;
  var fillLength = hasLen < len ? hasLen : len;
  if (fillLength <= 0) {
    return ;
  }
  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){
    a[i] = v;
  }
}

function blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {
  if (srcofs2 <= srcofs1) {
    for(var j = 0; j < blitLength; ++j){
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return ;
  }
  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  var lena1 = a1.length;
  var lena2 = a2.length;
  var srcofs1 = ofs1 < 0 ? Caml.int_max(lena1 + ofs1 | 0, 0) : ofs1;
  var srcofs2 = ofs2 < 0 ? Caml.int_max(lena2 + ofs2 | 0, 0) : ofs2;
  var blitLength = Caml.int_min(len, Caml.int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));
  if (srcofs2 <= srcofs1) {
    for(var j = 0; j < blitLength; ++j){
      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];
    }
    return ;
  }
  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];
  }
}

function forEachU(a, f) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    f(a[i]);
  }
}

function forEach(a, f) {
  forEachU(a, Curry.__1(f));
}

function mapU(a, f) {
  var l = a.length;
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(a[i]);
  }
  return r;
}

function map(a, f) {
  return mapU(a, Curry.__1(f));
}

function flatMapU(a, f) {
  return concatMany(mapU(a, f));
}

function flatMap(a, f) {
  return concatMany(mapU(a, Curry.__1(f)));
}

function getByU(a, p) {
  var l = a.length;
  var i = 0;
  var r;
  while(r === undefined && i < l) {
    var v = a[i];
    if (p(v)) {
      r = Caml_option.some(v);
    }
    i = i + 1 | 0;
  };
  return r;
}

function getBy(a, p) {
  return getByU(a, Curry.__1(p));
}

function getIndexByU(a, p) {
  var l = a.length;
  var i = 0;
  var r;
  while(r === undefined && i < l) {
    var v = a[i];
    if (p(v)) {
      r = i;
    }
    i = i + 1 | 0;
  };
  return r;
}

function getIndexBy(a, p) {
  return getIndexByU(a, Curry.__1(p));
}

function keepU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    if (f(v)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keep(a, f) {
  return keepU(a, Curry.__1(f));
}

function keepWithIndexU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    if (f(v, i)) {
      r[j] = v;
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepWithIndex(a, f) {
  return keepWithIndexU(a, Curry.__2(f));
}

function keepMapU(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    var v$1 = f(v);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepMap(a, f) {
  return keepMapU(a, Curry.__1(f));
}

function forEachWithIndexU(a, f) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    f(i, a[i]);
  }
}

function forEachWithIndex(a, f) {
  forEachWithIndexU(a, Curry.__2(f));
}

function mapWithIndexU(a, f) {
  var l = a.length;
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(i, a[i]);
  }
  return r;
}

function mapWithIndex(a, f) {
  return mapWithIndexU(a, Curry.__2(f));
}

function reduceU(a, x, f) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = f(r, a[i]);
  }
  return r;
}

function reduce(a, x, f) {
  return reduceU(a, x, Curry.__2(f));
}

function reduceReverseU(a, x, f) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = f(r, a[i]);
  }
  return r;
}

function reduceReverse(a, x, f) {
  return reduceReverseU(a, x, Curry.__2(f));
}

function reduceReverse2U(a, b, x, f) {
  var r = x;
  var len = Caml.int_min(a.length, b.length);
  for(var i = len - 1 | 0; i >= 0; --i){
    r = f(r, a[i], b[i]);
  }
  return r;
}

function reduceReverse2(a, b, x, f) {
  return reduceReverse2U(a, b, x, Curry.__3(f));
}

function reduceWithIndexU(a, x, f) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = f(r, a[i], i);
  }
  return r;
}

function reduceWithIndex(a, x, f) {
  return reduceWithIndexU(a, x, Curry.__3(f));
}

function everyU(arr, b) {
  var len = arr.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every(arr, f) {
  return everyU(arr, Curry.__1(f));
}

function someU(arr, b) {
  var len = arr.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      return false;
    }
    if (b(arr[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some(arr, f) {
  return someU(arr, Curry.__1(f));
}

function everyAux2(arr1, arr2, _i, b, len) {
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!b(arr1[i], arr2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every2U(a, b, p) {
  return everyAux2(a, b, 0, p, Caml.int_min(a.length, b.length));
}

function every2(a, b, p) {
  return every2U(a, b, Curry.__2(p));
}

function some2U(a, b, p) {
  var _i = 0;
  var len = Caml.int_min(a.length, b.length);
  while(true) {
    var i = _i;
    if (i === len) {
      return false;
    }
    if (p(a[i], b[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some2(a, b, p) {
  return some2U(a, b, Curry.__2(p));
}

function eqU(a, b, p) {
  var lena = a.length;
  var lenb = b.length;
  if (lena === lenb) {
    return everyAux2(a, b, 0, p, lena);
  } else {
    return false;
  }
}

function eq(a, b, p) {
  return eqU(a, b, Curry.__2(p));
}

function cmpU(a, b, p) {
  var lena = a.length;
  var lenb = b.length;
  if (lena > lenb) {
    return 1;
  } else if (lena < lenb) {
    return -1;
  } else {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === lena) {
        return 0;
      }
      var c = p(a[i], b[i]);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function cmp(a, b, p) {
  return cmpU(a, b, Curry.__2(p));
}

function partitionU(a, f) {
  var l = a.length;
  var i = 0;
  var j = 0;
  var a1 = new Array(l);
  var a2 = new Array(l);
  for(var ii = 0; ii < l; ++ii){
    var v = a[ii];
    if (f(v)) {
      a1[i] = v;
      i = i + 1 | 0;
    } else {
      a2[j] = v;
      j = j + 1 | 0;
    }
  }
  a1.length = i;
  a2.length = j;
  return [
          a1,
          a2
        ];
}

function partition(a, f) {
  return partitionU(a, Curry.__1(f));
}

function unzip(a) {
  var l = a.length;
  var a1 = new Array(l);
  var a2 = new Array(l);
  for(var i = 0; i < l; ++i){
    var match = a[i];
    a1[i] = match[0];
    a2[i] = match[1];
  }
  return [
          a1,
          a2
        ];
}

function joinWithU(a, sep, toString) {
  var l = a.length;
  if (l === 0) {
    return "";
  }
  var lastIndex = l - 1 | 0;
  var _i = 0;
  var _res = "";
  while(true) {
    var res = _res;
    var i = _i;
    if (i === lastIndex) {
      return res + toString(a[i]);
    }
    _res = res + (toString(a[i]) + sep);
    _i = i + 1 | 0;
    continue ;
  };
}

function joinWith(a, sep, toString) {
  return joinWithU(a, sep, Curry.__1(toString));
}

function initU(n, f) {
  var v = new Array(n);
  for(var i = 0; i < n; ++i){
    v[i] = f(i);
  }
  return v;
}

function init(n, f) {
  return initU(n, Curry.__1(f));
}

exports.get = get;
exports.getExn = getExn;
exports.set = set;
exports.setExn = setExn;
exports.shuffleInPlace = shuffleInPlace;
exports.shuffle = shuffle;
exports.reverseInPlace = reverseInPlace;
exports.reverse = reverse;
exports.make = make;
exports.range = range;
exports.rangeBy = rangeBy;
exports.makeByU = makeByU;
exports.makeBy = makeBy;
exports.makeByAndShuffleU = makeByAndShuffleU;
exports.makeByAndShuffle = makeByAndShuffle;
exports.zip = zip;
exports.zipByU = zipByU;
exports.zipBy = zipBy;
exports.unzip = unzip;
exports.concat = concat;
exports.concatMany = concatMany;
exports.slice = slice;
exports.sliceToEnd = sliceToEnd;
exports.fill = fill;
exports.blit = blit;
exports.blitUnsafe = blitUnsafe;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.mapU = mapU;
exports.map = map;
exports.flatMapU = flatMapU;
exports.flatMap = flatMap;
exports.getByU = getByU;
exports.getBy = getBy;
exports.getIndexByU = getIndexByU;
exports.getIndexBy = getIndexBy;
exports.keepU = keepU;
exports.keep = keep;
exports.keepWithIndexU = keepWithIndexU;
exports.keepWithIndex = keepWithIndex;
exports.keepMapU = keepMapU;
exports.keepMap = keepMap;
exports.forEachWithIndexU = forEachWithIndexU;
exports.forEachWithIndex = forEachWithIndex;
exports.mapWithIndexU = mapWithIndexU;
exports.mapWithIndex = mapWithIndex;
exports.partitionU = partitionU;
exports.partition = partition;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.reduceReverseU = reduceReverseU;
exports.reduceReverse = reduceReverse;
exports.reduceReverse2U = reduceReverse2U;
exports.reduceReverse2 = reduceReverse2;
exports.reduceWithIndexU = reduceWithIndexU;
exports.reduceWithIndex = reduceWithIndex;
exports.joinWithU = joinWithU;
exports.joinWith = joinWith;
exports.someU = someU;
exports.some = some;
exports.everyU = everyU;
exports.every = every;
exports.every2U = every2U;
exports.every2 = every2;
exports.some2U = some2U;
exports.some2 = some2;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
exports.initU = initU;
exports.init = init;
/* No side effect */

},{"./caml.js":26,"./caml_option.js":33,"./curry.js":37,"./js_math.js":42}],20:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Belt_Array = require("./belt_Array.js");
var Caml_option = require("./caml_option.js");
var Belt_SortArray = require("./belt_SortArray.js");

function head(x) {
  if (x) {
    return Caml_option.some(x.hd);
  }
  
}

function headExn(x) {
  if (x) {
    return x.hd;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function tail(x) {
  if (x) {
    return x.tl;
  }
  
}

function tailExn(x) {
  if (x) {
    return x.tl;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function add(xs, x) {
  return {
          hd: x,
          tl: xs
        };
}

function get(x, n) {
  if (n < 0) {
    return ;
  } else {
    var _x = x;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var x$1 = _x;
      if (!x$1) {
        return ;
      }
      if (n$1 === 0) {
        return Caml_option.some(x$1.hd);
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue ;
    };
  }
}

function getExn(x, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var _x = x;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var x$1 = _x;
    if (x$1) {
      if (n$1 === 0) {
        return x$1.hd;
      }
      _n = n$1 - 1 | 0;
      _x = x$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function partitionAux(p, _cell, _precX, _precY) {
  while(true) {
    var precY = _precY;
    var precX = _precX;
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var t = cell.tl;
    var h = cell.hd;
    var next = {
      hd: h,
      tl: /* [] */0
    };
    if (p(h)) {
      precX.tl = next;
      _precX = next;
      _cell = t;
      continue ;
    }
    precY.tl = next;
    _precY = next;
    _cell = t;
    continue ;
  };
}

function splitAux(_cell, _precX, _precY) {
  while(true) {
    var precY = _precY;
    var precX = _precX;
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var match = cell.hd;
    var nextA = {
      hd: match[0],
      tl: /* [] */0
    };
    var nextB = {
      hd: match[1],
      tl: /* [] */0
    };
    precX.tl = nextA;
    precY.tl = nextB;
    _precY = nextB;
    _precX = nextA;
    _cell = cell.tl;
    continue ;
  };
}

function copyAuxCont(_cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return prec;
    }
    var next = {
      hd: cellX.hd,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWitFilter(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h)) {
      var next = {
        hd: h,
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  };
}

function copyAuxWithFilterIndex(f, _cellX, _prec, _i) {
  while(true) {
    var i = _i;
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h, i)) {
      var next = {
        hd: h,
        tl: /* [] */0
      };
      prec.tl = next;
      _i = i + 1 | 0;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _i = i + 1 | 0;
    _cellX = t;
    continue ;
  };
}

function copyAuxWitFilterMap(f, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var t = cellX.tl;
    var h = f(cellX.hd);
    if (h !== undefined) {
      var next = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      prec.tl = next;
      _prec = next;
      _cellX = t;
      continue ;
    }
    _cellX = t;
    continue ;
  };
}

function removeAssocAuxWithMap(_cellX, x, _prec, f) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return false;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (f(h[0], x)) {
      prec.tl = t;
      return true;
    }
    var next = {
      hd: h,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue ;
  };
}

function setAssocAuxWithMap(_cellX, x, k, _prec, eq) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return false;
    }
    var t = cellX.tl;
    var h = cellX.hd;
    if (eq(h[0], x)) {
      prec.tl = {
        hd: [
          x,
          k
        ],
        tl: t
      };
      return true;
    }
    var next = {
      hd: h,
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = t;
    continue ;
  };
}

function copyAuxWithMap(_cellX, _prec, f) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    var next = {
      hd: f(cellX.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    continue ;
  };
}

function zipAux(_cellX, _cellY, _prec) {
  while(true) {
    var prec = _prec;
    var cellY = _cellY;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    if (!cellY) {
      return ;
    }
    var next = {
      hd: [
        cellX.hd,
        cellY.hd
      ],
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWithMap2(f, _cellX, _cellY, _prec) {
  while(true) {
    var prec = _prec;
    var cellY = _cellY;
    var cellX = _cellX;
    if (!cellX) {
      return ;
    }
    if (!cellY) {
      return ;
    }
    var next = {
      hd: f(cellX.hd, cellY.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellY = cellY.tl;
    _cellX = cellX.tl;
    continue ;
  };
}

function copyAuxWithMapI(f, _i, _cellX, _prec) {
  while(true) {
    var prec = _prec;
    var cellX = _cellX;
    var i = _i;
    if (!cellX) {
      return ;
    }
    var next = {
      hd: f(i, cellX.hd),
      tl: /* [] */0
    };
    prec.tl = next;
    _prec = next;
    _cellX = cellX.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function takeAux(_n, _cell, _prec) {
  while(true) {
    var prec = _prec;
    var cell = _cell;
    var n = _n;
    if (n === 0) {
      return true;
    }
    if (!cell) {
      return false;
    }
    var cell$1 = {
      hd: cell.hd,
      tl: /* [] */0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function splitAtAux(_n, _cell, _prec) {
  while(true) {
    var prec = _prec;
    var cell = _cell;
    var n = _n;
    if (n === 0) {
      return cell;
    }
    if (!cell) {
      return ;
    }
    var cell$1 = {
      hd: cell.hd,
      tl: /* [] */0
    };
    prec.tl = cell$1;
    _prec = cell$1;
    _cell = cell.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function take(lst, n) {
  if (n < 0) {
    return ;
  }
  if (n === 0) {
    return /* [] */0;
  }
  if (!lst) {
    return ;
  }
  var cell = {
    hd: lst.hd,
    tl: /* [] */0
  };
  var has = takeAux(n - 1 | 0, lst.tl, cell);
  if (has) {
    return cell;
  }
  
}

function drop(lst, n) {
  if (n < 0) {
    return ;
  } else {
    var _l = lst;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var l = _l;
      if (n$1 === 0) {
        return l;
      }
      if (!l) {
        return ;
      }
      _n = n$1 - 1 | 0;
      _l = l.tl;
      continue ;
    };
  }
}

function splitAt(lst, n) {
  if (n < 0) {
    return ;
  }
  if (n === 0) {
    return [
            /* [] */0,
            lst
          ];
  }
  if (!lst) {
    return ;
  }
  var cell = {
    hd: lst.hd,
    tl: /* [] */0
  };
  var rest = splitAtAux(n - 1 | 0, lst.tl, cell);
  if (rest !== undefined) {
    return [
            cell,
            rest
          ];
  }
  
}

function concat(xs, ys) {
  if (!xs) {
    return ys;
  }
  var cell = {
    hd: xs.hd,
    tl: /* [] */0
  };
  copyAuxCont(xs.tl, cell).tl = ys;
  return cell;
}

function mapU(xs, f) {
  if (!xs) {
    return /* [] */0;
  }
  var cell = {
    hd: f(xs.hd),
    tl: /* [] */0
  };
  copyAuxWithMap(xs.tl, cell, f);
  return cell;
}

function map(xs, f) {
  return mapU(xs, Curry.__1(f));
}

function zipByU(l1, l2, f) {
  if (!l1) {
    return /* [] */0;
  }
  if (!l2) {
    return /* [] */0;
  }
  var cell = {
    hd: f(l1.hd, l2.hd),
    tl: /* [] */0
  };
  copyAuxWithMap2(f, l1.tl, l2.tl, cell);
  return cell;
}

function zipBy(l1, l2, f) {
  return zipByU(l1, l2, Curry.__2(f));
}

function mapWithIndexU(xs, f) {
  if (!xs) {
    return /* [] */0;
  }
  var cell = {
    hd: f(0, xs.hd),
    tl: /* [] */0
  };
  copyAuxWithMapI(f, 1, xs.tl, cell);
  return cell;
}

function mapWithIndex(xs, f) {
  return mapWithIndexU(xs, Curry.__2(f));
}

function makeByU(n, f) {
  if (n <= 0) {
    return /* [] */0;
  }
  var headX = {
    hd: f(0),
    tl: /* [] */0
  };
  var cur = headX;
  var i = 1;
  while(i < n) {
    var v = {
      hd: f(i),
      tl: /* [] */0
    };
    cur.tl = v;
    cur = v;
    i = i + 1 | 0;
  };
  return headX;
}

function makeBy(n, f) {
  return makeByU(n, Curry.__1(f));
}

function make(n, v) {
  if (n <= 0) {
    return /* [] */0;
  }
  var headX = {
    hd: v,
    tl: /* [] */0
  };
  var cur = headX;
  var i = 1;
  while(i < n) {
    var v$1 = {
      hd: v,
      tl: /* [] */0
    };
    cur.tl = v$1;
    cur = v$1;
    i = i + 1 | 0;
  };
  return headX;
}

function length(xs) {
  var _x = xs;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var x = _x;
    if (!x) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _x = x.tl;
    continue ;
  };
}

function fillAux(arr, _i, _x) {
  while(true) {
    var x = _x;
    var i = _i;
    if (!x) {
      return ;
    }
    arr[i] = x.hd;
    _x = x.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fromArray(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function toArray(x) {
  var len = length(x);
  var arr = new Array(len);
  fillAux(arr, 0, x);
  return arr;
}

function shuffle(xs) {
  var v = toArray(xs);
  Belt_Array.shuffleInPlace(v);
  return fromArray(v);
}

function reverseConcat(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  };
}

function reverse(l) {
  return reverseConcat(l, /* [] */0);
}

function flattenAux(_prec, _xs) {
  while(true) {
    var xs = _xs;
    var prec = _prec;
    if (xs) {
      _xs = xs.tl;
      _prec = copyAuxCont(xs.hd, prec);
      continue ;
    }
    prec.tl = /* [] */0;
    return ;
  };
}

function flatten(_xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var match = xs.hd;
    if (match) {
      var cell = {
        hd: match.hd,
        tl: /* [] */0
      };
      flattenAux(copyAuxCont(match.tl, cell), xs.tl);
      return cell;
    }
    _xs = xs.tl;
    continue ;
  };
}

function concatMany(xs) {
  var len = xs.length;
  if (len === 1) {
    return xs[0];
  }
  if (len === 0) {
    return /* [] */0;
  }
  var len$1 = xs.length;
  var v = xs[len$1 - 1 | 0];
  for(var i = len$1 - 2 | 0; i >= 0; --i){
    v = concat(xs[i], v);
  }
  return v;
}

function mapReverseU(l, f) {
  var _accu = /* [] */0;
  var _xs = l;
  while(true) {
    var xs = _xs;
    var accu = _accu;
    if (!xs) {
      return accu;
    }
    _xs = xs.tl;
    _accu = {
      hd: f(xs.hd),
      tl: accu
    };
    continue ;
  };
}

function mapReverse(l, f) {
  return mapReverseU(l, Curry.__1(f));
}

function forEachU(_xs, f) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    f(xs.hd);
    _xs = xs.tl;
    continue ;
  };
}

function forEach(xs, f) {
  forEachU(xs, Curry.__1(f));
}

function forEachWithIndexU(l, f) {
  var _xs = l;
  var _i = 0;
  while(true) {
    var i = _i;
    var xs = _xs;
    if (!xs) {
      return ;
    }
    f(i, xs.hd);
    _i = i + 1 | 0;
    _xs = xs.tl;
    continue ;
  };
}

function forEachWithIndex(l, f) {
  forEachWithIndexU(l, Curry.__2(f));
}

function reduceU(_l, _accu, f) {
  while(true) {
    var accu = _accu;
    var l = _l;
    if (!l) {
      return accu;
    }
    _accu = f(accu, l.hd);
    _l = l.tl;
    continue ;
  };
}

function reduce(l, accu, f) {
  return reduceU(l, accu, Curry.__2(f));
}

function reduceReverseUnsafeU(l, accu, f) {
  if (l) {
    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);
  } else {
    return accu;
  }
}

function reduceReverseU(l, acc, f) {
  var len = length(l);
  if (len < 1000) {
    return reduceReverseUnsafeU(l, acc, f);
  } else {
    return Belt_Array.reduceReverseU(toArray(l), acc, f);
  }
}

function reduceReverse(l, accu, f) {
  return reduceReverseU(l, accu, Curry.__2(f));
}

function reduceWithIndexU(l, acc, f) {
  var _l = l;
  var _acc = acc;
  var _i = 0;
  while(true) {
    var i = _i;
    var acc$1 = _acc;
    var l$1 = _l;
    if (!l$1) {
      return acc$1;
    }
    _i = i + 1 | 0;
    _acc = f(acc$1, l$1.hd, i);
    _l = l$1.tl;
    continue ;
  };
}

function reduceWithIndex(l, acc, f) {
  return reduceWithIndexU(l, acc, Curry.__3(f));
}

function mapReverse2U(l1, l2, f) {
  var _l1 = l1;
  var _l2 = l2;
  var _accu = /* [] */0;
  while(true) {
    var accu = _accu;
    var l2$1 = _l2;
    var l1$1 = _l1;
    if (!l1$1) {
      return accu;
    }
    if (!l2$1) {
      return accu;
    }
    _accu = {
      hd: f(l1$1.hd, l2$1.hd),
      tl: accu
    };
    _l2 = l2$1.tl;
    _l1 = l1$1.tl;
    continue ;
  };
}

function mapReverse2(l1, l2, f) {
  return mapReverse2U(l1, l2, Curry.__2(f));
}

function forEach2U(_l1, _l2, f) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return ;
    }
    if (!l2) {
      return ;
    }
    f(l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function forEach2(l1, l2, f) {
  forEach2U(l1, l2, Curry.__2(f));
}

function reduce2U(_l1, _l2, _accu, f) {
  while(true) {
    var accu = _accu;
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return accu;
    }
    if (!l2) {
      return accu;
    }
    _accu = f(accu, l1.hd, l2.hd);
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function reduce2(l1, l2, acc, f) {
  return reduce2U(l1, l2, acc, Curry.__3(f));
}

function reduceReverse2UnsafeU(l1, l2, accu, f) {
  if (l1 && l2) {
    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);
  } else {
    return accu;
  }
}

function reduceReverse2U(l1, l2, acc, f) {
  var len = length(l1);
  if (len < 1000) {
    return reduceReverse2UnsafeU(l1, l2, acc, f);
  } else {
    return Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);
  }
}

function reduceReverse2(l1, l2, acc, f) {
  return reduceReverse2U(l1, l2, acc, Curry.__3(f));
}

function everyU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return true;
    }
    if (!p(xs.hd)) {
      return false;
    }
    _xs = xs.tl;
    continue ;
  };
}

function every(xs, p) {
  return everyU(xs, Curry.__1(p));
}

function someU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (p(xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function some(xs, p) {
  return someU(xs, Curry.__1(p));
}

function every2U(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return true;
    }
    if (!l2) {
      return true;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function every2(l1, l2, p) {
  return every2U(l1, l2, Curry.__2(p));
}

function cmpByLength(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function cmpU(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    var c = p(l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function cmp(l1, l2, f) {
  return cmpU(l1, l2, Curry.__2(f));
}

function eqU(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!p(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function eq(l1, l2, f) {
  return eqU(l1, l2, Curry.__2(f));
}

function some2U(_l1, _l2, p) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return false;
    }
    if (!l2) {
      return false;
    }
    if (p(l1.hd, l2.hd)) {
      return true;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function some2(l1, l2, p) {
  return some2U(l1, l2, Curry.__2(p));
}

function hasU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd, x)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function has(xs, x, eq) {
  return hasU(xs, x, Curry.__2(eq));
}

function getAssocU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var match = xs.hd;
    if (eq(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _xs = xs.tl;
    continue ;
  };
}

function getAssoc(xs, x, eq) {
  return getAssocU(xs, x, Curry.__2(eq));
}

function hasAssocU(_xs, x, eq) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (eq(xs.hd[0], x)) {
      return true;
    }
    _xs = xs.tl;
    continue ;
  };
}

function hasAssoc(xs, x, eq) {
  return hasAssocU(xs, x, Curry.__2(eq));
}

function removeAssocU(xs, x, eq) {
  if (!xs) {
    return /* [] */0;
  }
  var l = xs.tl;
  var pair = xs.hd;
  if (eq(pair[0], x)) {
    return l;
  }
  var cell = {
    hd: pair,
    tl: /* [] */0
  };
  var removed = removeAssocAuxWithMap(l, x, cell, eq);
  if (removed) {
    return cell;
  } else {
    return xs;
  }
}

function removeAssoc(xs, x, eq) {
  return removeAssocU(xs, x, Curry.__2(eq));
}

function setAssocU(xs, x, k, eq) {
  if (!xs) {
    return {
            hd: [
              x,
              k
            ],
            tl: /* [] */0
          };
  }
  var l = xs.tl;
  var pair = xs.hd;
  if (eq(pair[0], x)) {
    return {
            hd: [
              x,
              k
            ],
            tl: l
          };
  }
  var cell = {
    hd: pair,
    tl: /* [] */0
  };
  var replaced = setAssocAuxWithMap(l, x, k, cell, eq);
  if (replaced) {
    return cell;
  } else {
    return {
            hd: [
              x,
              k
            ],
            tl: xs
          };
  }
}

function setAssoc(xs, x, k, eq) {
  return setAssocU(xs, x, k, Curry.__2(eq));
}

function sortU(xs, cmp) {
  var arr = toArray(xs);
  Belt_SortArray.stableSortInPlaceByU(arr, cmp);
  return fromArray(arr);
}

function sort(xs, cmp) {
  return sortU(xs, Curry.__2(cmp));
}

function getByU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var x = xs.hd;
    if (p(x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue ;
  };
}

function getBy(xs, p) {
  return getByU(xs, Curry.__1(p));
}

function keepU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = xs.hd;
    if (p(h)) {
      var cell = {
        hd: h,
        tl: /* [] */0
      };
      copyAuxWitFilter(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  };
}

function keep(xs, p) {
  return keepU(xs, Curry.__1(p));
}

function keepWithIndexU(xs, p) {
  var _xs = xs;
  var _i = 0;
  while(true) {
    var i = _i;
    var xs$1 = _xs;
    if (!xs$1) {
      return /* [] */0;
    }
    var t = xs$1.tl;
    var h = xs$1.hd;
    if (p(h, i)) {
      var cell = {
        hd: h,
        tl: /* [] */0
      };
      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);
      return cell;
    }
    _i = i + 1 | 0;
    _xs = t;
    continue ;
  };
}

function keepWithIndex(xs, p) {
  return keepWithIndexU(xs, Curry.__2(p));
}

function keepMapU(_xs, p) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var t = xs.tl;
    var h = p(xs.hd);
    if (h !== undefined) {
      var cell = {
        hd: Caml_option.valFromOption(h),
        tl: /* [] */0
      };
      copyAuxWitFilterMap(p, t, cell);
      return cell;
    }
    _xs = t;
    continue ;
  };
}

function keepMap(xs, p) {
  return keepMapU(xs, Curry.__1(p));
}

function partitionU(l, p) {
  if (!l) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var h = l.hd;
  var nextX = {
    hd: h,
    tl: /* [] */0
  };
  var nextY = {
    hd: h,
    tl: /* [] */0
  };
  var b = p(h);
  partitionAux(p, l.tl, nextX, nextY);
  if (b) {
    return [
            nextX,
            nextY.tl
          ];
  } else {
    return [
            nextX.tl,
            nextY
          ];
  }
}

function partition(l, p) {
  return partitionU(l, Curry.__1(p));
}

function unzip(xs) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var match = xs.hd;
  var cellX = {
    hd: match[0],
    tl: /* [] */0
  };
  var cellY = {
    hd: match[1],
    tl: /* [] */0
  };
  splitAux(xs.tl, cellX, cellY);
  return [
          cellX,
          cellY
        ];
}

function zip(l1, l2) {
  if (!l1) {
    return /* [] */0;
  }
  if (!l2) {
    return /* [] */0;
  }
  var cell = {
    hd: [
      l1.hd,
      l2.hd
    ],
    tl: /* [] */0
  };
  zipAux(l1.tl, l2.tl, cell);
  return cell;
}

var size = length;

var filter = keep;

var filterWithIndex = keepWithIndex;

exports.length = length;
exports.size = size;
exports.head = head;
exports.headExn = headExn;
exports.tail = tail;
exports.tailExn = tailExn;
exports.add = add;
exports.get = get;
exports.getExn = getExn;
exports.make = make;
exports.makeByU = makeByU;
exports.makeBy = makeBy;
exports.shuffle = shuffle;
exports.drop = drop;
exports.take = take;
exports.splitAt = splitAt;
exports.concat = concat;
exports.concatMany = concatMany;
exports.reverseConcat = reverseConcat;
exports.flatten = flatten;
exports.mapU = mapU;
exports.map = map;
exports.zip = zip;
exports.zipByU = zipByU;
exports.zipBy = zipBy;
exports.mapWithIndexU = mapWithIndexU;
exports.mapWithIndex = mapWithIndex;
exports.fromArray = fromArray;
exports.toArray = toArray;
exports.reverse = reverse;
exports.mapReverseU = mapReverseU;
exports.mapReverse = mapReverse;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.forEachWithIndexU = forEachWithIndexU;
exports.forEachWithIndex = forEachWithIndex;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.reduceWithIndexU = reduceWithIndexU;
exports.reduceWithIndex = reduceWithIndex;
exports.reduceReverseU = reduceReverseU;
exports.reduceReverse = reduceReverse;
exports.mapReverse2U = mapReverse2U;
exports.mapReverse2 = mapReverse2;
exports.forEach2U = forEach2U;
exports.forEach2 = forEach2;
exports.reduce2U = reduce2U;
exports.reduce2 = reduce2;
exports.reduceReverse2U = reduceReverse2U;
exports.reduceReverse2 = reduceReverse2;
exports.everyU = everyU;
exports.every = every;
exports.someU = someU;
exports.some = some;
exports.every2U = every2U;
exports.every2 = every2;
exports.some2U = some2U;
exports.some2 = some2;
exports.cmpByLength = cmpByLength;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
exports.hasU = hasU;
exports.has = has;
exports.getByU = getByU;
exports.getBy = getBy;
exports.keepU = keepU;
exports.keep = keep;
exports.filter = filter;
exports.keepWithIndexU = keepWithIndexU;
exports.keepWithIndex = keepWithIndex;
exports.filterWithIndex = filterWithIndex;
exports.keepMapU = keepMapU;
exports.keepMap = keepMap;
exports.partitionU = partitionU;
exports.partition = partition;
exports.unzip = unzip;
exports.getAssocU = getAssocU;
exports.getAssoc = getAssoc;
exports.hasAssocU = hasAssocU;
exports.hasAssoc = hasAssoc;
exports.removeAssocU = removeAssocU;
exports.removeAssoc = removeAssoc;
exports.setAssocU = setAssocU;
exports.setAssoc = setAssoc;
exports.sortU = sortU;
exports.sort = sort;
/* No side effect */

},{"./belt_Array.js":19,"./belt_SortArray.js":23,"./caml_option.js":33,"./curry.js":37}],21:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_option = require("./caml_option.js");
var Belt_internalAVLtree = require("./belt_internalAVLtree.js");
var Belt_internalMapString = require("./belt_internalMapString.js");

function set(t, newK, newD) {
  if (t === undefined) {
    return Belt_internalAVLtree.singleton(newK, newD);
  }
  var k = t.k;
  if (newK === k) {
    return Belt_internalAVLtree.updateValue(t, newD);
  }
  var v = t.v;
  if (newK < k) {
    return Belt_internalAVLtree.bal(set(t.l, newK, newD), k, v, t.r);
  } else {
    return Belt_internalAVLtree.bal(t.l, k, v, set(t.r, newK, newD));
  }
}

function updateU(t, x, f) {
  if (t !== undefined) {
    var k = t.k;
    if (x === k) {
      var data = f(Caml_option.some(t.v));
      if (data !== undefined) {
        return Belt_internalAVLtree.updateValue(t, Caml_option.valFromOption(data));
      }
      var l = t.l;
      var r = t.r;
      if (l === undefined) {
        return r;
      }
      if (r === undefined) {
        return l;
      }
      var kr = {
        contents: r.k
      };
      var vr = {
        contents: r.v
      };
      var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);
      return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
    }
    var v = t.v;
    var l$1 = t.l;
    var r$2 = t.r;
    if (x < k) {
      var ll = updateU(l$1, x, f);
      if (l$1 === ll) {
        return t;
      } else {
        return Belt_internalAVLtree.bal(ll, k, v, r$2);
      }
    }
    var rr = updateU(r$2, x, f);
    if (r$2 === rr) {
      return t;
    } else {
      return Belt_internalAVLtree.bal(l$1, k, v, rr);
    }
  }
  var data$1 = f(undefined);
  if (data$1 !== undefined) {
    return Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));
  } else {
    return t;
  }
}

function update(t, x, f) {
  return updateU(t, x, Curry.__1(f));
}

function removeAux(n, x) {
  var v = n.k;
  var l = n.l;
  var r = n.r;
  if (x === v) {
    if (l === undefined) {
      return r;
    }
    if (r === undefined) {
      return l;
    }
    var kr = {
      contents: r.k
    };
    var vr = {
      contents: r.v
    };
    var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);
    return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
  }
  if (x < v) {
    if (l === undefined) {
      return n;
    }
    var ll = removeAux(l, x);
    if (ll === l) {
      return n;
    } else {
      return Belt_internalAVLtree.bal(ll, v, n.v, r);
    }
  }
  if (r === undefined) {
    return n;
  }
  var rr = removeAux(r, x);
  return Belt_internalAVLtree.bal(l, v, n.v, rr);
}

function remove(n, x) {
  if (n !== undefined) {
    return removeAux(n, x);
  }
  
}

function removeMany(t, keys) {
  var len = keys.length;
  if (t !== undefined) {
    var _t = t;
    var _i = 0;
    while(true) {
      var i = _i;
      var t$1 = _t;
      if (i >= len) {
        return t$1;
      }
      var ele = keys[i];
      var u = removeAux(t$1, ele);
      if (u === undefined) {
        return u;
      }
      _i = i + 1 | 0;
      _t = u;
      continue ;
    };
  }
  
}

function mergeMany(h, arr) {
  var len = arr.length;
  var v = h;
  for(var i = 0; i < len; ++i){
    var match = arr[i];
    v = set(v, match[0], match[1]);
  }
  return v;
}

var empty;

var isEmpty = Belt_internalAVLtree.isEmpty;

var has = Belt_internalMapString.has;

var cmpU = Belt_internalMapString.cmpU;

var cmp = Belt_internalMapString.cmp;

var eqU = Belt_internalMapString.eqU;

var eq = Belt_internalMapString.eq;

var findFirstByU = Belt_internalAVLtree.findFirstByU;

var findFirstBy = Belt_internalAVLtree.findFirstBy;

var forEachU = Belt_internalAVLtree.forEachU;

var forEach = Belt_internalAVLtree.forEach;

var reduceU = Belt_internalAVLtree.reduceU;

var reduce = Belt_internalAVLtree.reduce;

var everyU = Belt_internalAVLtree.everyU;

var every = Belt_internalAVLtree.every;

var someU = Belt_internalAVLtree.someU;

var some = Belt_internalAVLtree.some;

var size = Belt_internalAVLtree.size;

var toList = Belt_internalAVLtree.toList;

var toArray = Belt_internalAVLtree.toArray;

var fromArray = Belt_internalMapString.fromArray;

var keysToArray = Belt_internalAVLtree.keysToArray;

var valuesToArray = Belt_internalAVLtree.valuesToArray;

var minKey = Belt_internalAVLtree.minKey;

var minKeyUndefined = Belt_internalAVLtree.minKeyUndefined;

var maxKey = Belt_internalAVLtree.maxKey;

var maxKeyUndefined = Belt_internalAVLtree.maxKeyUndefined;

var minimum = Belt_internalAVLtree.minimum;

var minUndefined = Belt_internalAVLtree.minUndefined;

var maximum = Belt_internalAVLtree.maximum;

var maxUndefined = Belt_internalAVLtree.maxUndefined;

var get = Belt_internalMapString.get;

var getUndefined = Belt_internalMapString.getUndefined;

var getWithDefault = Belt_internalMapString.getWithDefault;

var getExn = Belt_internalMapString.getExn;

var checkInvariantInternal = Belt_internalAVLtree.checkInvariantInternal;

var mergeU = Belt_internalMapString.mergeU;

var merge = Belt_internalMapString.merge;

var keepU = Belt_internalAVLtree.keepSharedU;

var keep = Belt_internalAVLtree.keepShared;

var partitionU = Belt_internalAVLtree.partitionSharedU;

var partition = Belt_internalAVLtree.partitionShared;

var split = Belt_internalMapString.split;

var mapU = Belt_internalAVLtree.mapU;

var map = Belt_internalAVLtree.map;

var mapWithKeyU = Belt_internalAVLtree.mapWithKeyU;

var mapWithKey = Belt_internalAVLtree.mapWithKey;

exports.empty = empty;
exports.isEmpty = isEmpty;
exports.has = has;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
exports.findFirstByU = findFirstByU;
exports.findFirstBy = findFirstBy;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.everyU = everyU;
exports.every = every;
exports.someU = someU;
exports.some = some;
exports.size = size;
exports.toList = toList;
exports.toArray = toArray;
exports.fromArray = fromArray;
exports.keysToArray = keysToArray;
exports.valuesToArray = valuesToArray;
exports.minKey = minKey;
exports.minKeyUndefined = minKeyUndefined;
exports.maxKey = maxKey;
exports.maxKeyUndefined = maxKeyUndefined;
exports.minimum = minimum;
exports.minUndefined = minUndefined;
exports.maximum = maximum;
exports.maxUndefined = maxUndefined;
exports.get = get;
exports.getUndefined = getUndefined;
exports.getWithDefault = getWithDefault;
exports.getExn = getExn;
exports.checkInvariantInternal = checkInvariantInternal;
exports.remove = remove;
exports.removeMany = removeMany;
exports.set = set;
exports.updateU = updateU;
exports.update = update;
exports.mergeU = mergeU;
exports.merge = merge;
exports.mergeMany = mergeMany;
exports.keepU = keepU;
exports.keep = keep;
exports.partitionU = partitionU;
exports.partition = partition;
exports.split = split;
exports.mapU = mapU;
exports.map = map;
exports.mapWithKeyU = mapWithKeyU;
exports.mapWithKey = mapWithKey;
/* No side effect */

},{"./belt_internalAVLtree.js":24,"./belt_internalMapString.js":25,"./caml_option.js":33,"./curry.js":37}],22:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_option = require("./caml_option.js");

function keepU(opt, p) {
  if (opt !== undefined && p(Caml_option.valFromOption(opt))) {
    return opt;
  }
  
}

function keep(opt, p) {
  return keepU(opt, Curry.__1(p));
}

function forEachU(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function forEach(opt, f) {
  forEachU(opt, Curry.__1(f));
}

function getExn(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function mapWithDefaultU(opt, $$default, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  } else {
    return $$default;
  }
}

function mapWithDefault(opt, $$default, f) {
  return mapWithDefaultU(opt, $$default, Curry.__1(f));
}

function mapU(opt, f) {
  if (opt !== undefined) {
    return Caml_option.some(f(Caml_option.valFromOption(opt)));
  }
  
}

function map(opt, f) {
  return mapU(opt, Curry.__1(f));
}

function flatMapU(opt, f) {
  if (opt !== undefined) {
    return f(Caml_option.valFromOption(opt));
  }
  
}

function flatMap(opt, f) {
  return flatMapU(opt, Curry.__1(f));
}

function getWithDefault(opt, $$default) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return $$default;
  }
}

function orElse(opt, other) {
  if (opt !== undefined) {
    return opt;
  } else {
    return other;
  }
}

function isSome(param) {
  return param !== undefined;
}

function isNone(x) {
  return x === undefined;
}

function eqU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function eq(a, b, f) {
  return eqU(a, b, Curry.__2(f));
}

function cmpU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return 1;
    }
  } else if (b !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function cmp(a, b, f) {
  return cmpU(a, b, Curry.__2(f));
}

exports.keepU = keepU;
exports.keep = keep;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.getExn = getExn;
exports.mapWithDefaultU = mapWithDefaultU;
exports.mapWithDefault = mapWithDefault;
exports.mapU = mapU;
exports.map = map;
exports.flatMapU = flatMapU;
exports.flatMap = flatMap;
exports.getWithDefault = getWithDefault;
exports.orElse = orElse;
exports.isSome = isSome;
exports.isNone = isNone;
exports.eqU = eqU;
exports.eq = eq;
exports.cmpU = cmpU;
exports.cmp = cmp;
/* No side effect */

},{"./caml_option.js":33,"./curry.js":37}],23:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Belt_Array = require("./belt_Array.js");

function sortedLengthAuxMore(xs, _prec, _acc, len, lt) {
  while(true) {
    var acc = _acc;
    var prec = _prec;
    if (acc >= len) {
      return acc;
    }
    var v = xs[acc];
    if (!lt(v, prec)) {
      return acc;
    }
    _acc = acc + 1 | 0;
    _prec = v;
    continue ;
  };
}

function strictlySortedLengthU(xs, lt) {
  var len = xs.length;
  if (len === 0 || len === 1) {
    return len;
  }
  var x0 = xs[0];
  var x1 = xs[1];
  if (lt(x0, x1)) {
    var _prec = x1;
    var _acc = 2;
    while(true) {
      var acc = _acc;
      var prec = _prec;
      if (acc >= len) {
        return acc;
      }
      var v = xs[acc];
      if (!lt(prec, v)) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _prec = v;
      continue ;
    };
  } else if (lt(x1, x0)) {
    return -sortedLengthAuxMore(xs, x1, 2, len, lt) | 0;
  } else {
    return 1;
  }
}

function strictlySortedLength(xs, lt) {
  return strictlySortedLengthU(xs, Curry.__2(lt));
}

function isSortedU(a, cmp) {
  var len = a.length;
  if (len === 0) {
    return true;
  } else {
    var _i = 0;
    var last_bound = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i === last_bound) {
        return true;
      }
      if (cmp(a[i], a[i + 1 | 0]) > 0) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function isSorted(a, cmp) {
  return isSortedU(a, Curry.__2(cmp));
}

function merge(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    if (cmp(s1, s2) <= 0) {
      dst[d] = s1;
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return Belt_Array.blitUnsafe(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      }
      _d = d + 1 | 0;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    dst[d] = s2;
    var i2$1 = i2 + 1 | 0;
    if (i2$1 >= src2r) {
      return Belt_Array.blitUnsafe(src, i1, dst, d + 1 | 0, src1r - i1 | 0);
    }
    _d = d + 1 | 0;
    _s2 = src2[i2$1];
    _i2 = i2$1;
    continue ;
  };
}

function unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      var i1$1 = i1 + 1 | 0;
      var d$1 = d + 1 | 0;
      if (i1$1 < src1r) {
        _d = d$1;
        _s1 = src[i1$1];
        _i1 = i1$1;
        continue ;
      }
      Belt_Array.blitUnsafe(src2, i2, dst, d$1, src2r - i2 | 0);
      return (d$1 + src2r | 0) - i2 | 0;
    }
    if (c === 0) {
      dst[d] = s1;
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      var d$2 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          Belt_Array.blitUnsafe(src2, i2$1, dst, d$2, src2r - i2$1 | 0);
          return (d$2 + src2r | 0) - i2$1 | 0;
        } else {
          Belt_Array.blitUnsafe(src, i1$2, dst, d$2, src1r - i1$2 | 0);
          return (d$2 + src1r | 0) - i1$2 | 0;
        }
      }
      _d = d$2;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    dst[d] = s2;
    var i2$2 = i2 + 1 | 0;
    var d$3 = d + 1 | 0;
    if (i2$2 < src2r) {
      _d = d$3;
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue ;
    }
    Belt_Array.blitUnsafe(src, i1, dst, d$3, src1r - i1 | 0);
    return (d$3 + src1r | 0) - i1 | 0;
  };
}

function union(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return unionU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d;
      }
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    if (c === 0) {
      dst[d] = s1;
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      var d$1 = d + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        return d$1;
      }
      _d = d$1;
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    var i2$2 = i2 + 1 | 0;
    if (i2$2 >= src2r) {
      return d;
    }
    _s2 = src2[i2$2];
    _i2 = i2$2;
    continue ;
  };
}

function intersect(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return intersectU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  var src1r = src1ofs + src1len | 0;
  var src2r = src2ofs + src2len | 0;
  var _i1 = src1ofs;
  var _s1 = src[src1ofs];
  var _i2 = src2ofs;
  var _s2 = src2[src2ofs];
  var _d = dstofs;
  while(true) {
    var d = _d;
    var s2 = _s2;
    var i2 = _i2;
    var s1 = _s1;
    var i1 = _i1;
    var c = cmp(s1, s2);
    if (c < 0) {
      dst[d] = s1;
      var d$1 = d + 1 | 0;
      var i1$1 = i1 + 1 | 0;
      if (i1$1 >= src1r) {
        return d$1;
      }
      _d = d$1;
      _s1 = src[i1$1];
      _i1 = i1$1;
      continue ;
    }
    if (c === 0) {
      var i1$2 = i1 + 1 | 0;
      var i2$1 = i2 + 1 | 0;
      if (!(i1$2 < src1r && i2$1 < src2r)) {
        if (i1$2 === src1r) {
          return d;
        } else {
          Belt_Array.blitUnsafe(src, i1$2, dst, d, src1r - i1$2 | 0);
          return (d + src1r | 0) - i1$2 | 0;
        }
      }
      _s2 = src2[i2$1];
      _i2 = i2$1;
      _s1 = src[i1$2];
      _i1 = i1$2;
      continue ;
    }
    var i2$2 = i2 + 1 | 0;
    if (i2$2 < src2r) {
      _s2 = src2[i2$2];
      _i2 = i2$2;
      continue ;
    }
    Belt_Array.blitUnsafe(src, i1, dst, d, src1r - i1 | 0);
    return (d + src1r | 0) - i1 | 0;
  };
}

function diff(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, cmp) {
  return diffU(src, src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs, Curry.__2(cmp));
}

function insertionSort(src, srcofs, dst, dstofs, len, cmp) {
  for(var i = 0; i < len; ++i){
    var e = src[srcofs + i | 0];
    var j = (dstofs + i | 0) - 1 | 0;
    while(j >= dstofs && cmp(dst[j], e) > 0) {
      dst[j + 1 | 0] = dst[j];
      j = j - 1 | 0;
    };
    dst[j + 1 | 0] = e;
  }
}

function sortTo(src, srcofs, dst, dstofs, len, cmp) {
  if (len <= 5) {
    return insertionSort(src, srcofs, dst, dstofs, len, cmp);
  }
  var l1 = len / 2 | 0;
  var l2 = len - l1 | 0;
  sortTo(src, srcofs + l1 | 0, dst, dstofs + l1 | 0, l2, cmp);
  sortTo(src, srcofs, src, srcofs + l2 | 0, l1, cmp);
  merge(src, srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs, cmp);
}

function stableSortInPlaceByU(a, cmp) {
  var l = a.length;
  if (l <= 5) {
    return insertionSort(a, 0, a, 0, l, cmp);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = new Array(l2);
  sortTo(a, l1, t, 0, l2, cmp);
  sortTo(a, 0, a, l2, l1, cmp);
  merge(a, l2, l1, t, 0, l2, a, 0, cmp);
}

function stableSortInPlaceBy(a, cmp) {
  stableSortInPlaceByU(a, Curry.__2(cmp));
}

function stableSortByU(a, cmp) {
  var b = a.slice(0);
  stableSortInPlaceByU(b, cmp);
  return b;
}

function stableSortBy(a, cmp) {
  return stableSortByU(a, Curry.__2(cmp));
}

function binarySearchByU(sorted, key, cmp) {
  var len = sorted.length;
  if (len === 0) {
    return -1;
  }
  var lo = sorted[0];
  var c = cmp(key, lo);
  if (c < 0) {
    return -1;
  }
  var hi = sorted[len - 1 | 0];
  var c2 = cmp(key, hi);
  if (c2 > 0) {
    return -(len + 1 | 0) | 0;
  } else {
    var _lo = 0;
    var _hi = len - 1 | 0;
    while(true) {
      var hi$1 = _hi;
      var lo$1 = _lo;
      var mid = (lo$1 + hi$1 | 0) / 2 | 0;
      var midVal = sorted[mid];
      var c$1 = cmp(key, midVal);
      if (c$1 === 0) {
        return mid;
      }
      if (c$1 < 0) {
        if (hi$1 === mid) {
          if (cmp(sorted[lo$1], key) === 0) {
            return lo$1;
          } else {
            return -(hi$1 + 1 | 0) | 0;
          }
        }
        _hi = mid;
        continue ;
      }
      if (lo$1 === mid) {
        if (cmp(sorted[hi$1], key) === 0) {
          return hi$1;
        } else {
          return -(hi$1 + 1 | 0) | 0;
        }
      }
      _lo = mid;
      continue ;
    };
  }
}

function binarySearchBy(sorted, key, cmp) {
  return binarySearchByU(sorted, key, Curry.__2(cmp));
}

var Int;

var $$String;

exports.Int = Int;
exports.$$String = $$String;
exports.strictlySortedLengthU = strictlySortedLengthU;
exports.strictlySortedLength = strictlySortedLength;
exports.isSortedU = isSortedU;
exports.isSorted = isSorted;
exports.stableSortInPlaceByU = stableSortInPlaceByU;
exports.stableSortInPlaceBy = stableSortInPlaceBy;
exports.stableSortByU = stableSortByU;
exports.stableSortBy = stableSortBy;
exports.binarySearchByU = binarySearchByU;
exports.binarySearchBy = binarySearchBy;
exports.unionU = unionU;
exports.union = union;
exports.intersectU = intersectU;
exports.intersect = intersect;
exports.diffU = diffU;
exports.diff = diff;
/* No side effect */

},{"./belt_Array.js":19,"./curry.js":37}],24:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_option = require("./caml_option.js");
var Belt_SortArray = require("./belt_SortArray.js");

function treeHeight(n) {
  if (n !== undefined) {
    return n.h;
  } else {
    return 0;
  }
}

function copy(n) {
  if (n !== undefined) {
    return {
            k: n.k,
            v: n.v,
            h: n.h,
            l: copy(n.l),
            r: copy(n.r)
          };
  } else {
    return n;
  }
}

function create(l, x, d, r) {
  var hl = treeHeight(l);
  var hr = treeHeight(r);
  return {
          k: x,
          v: d,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
          l: l,
          r: r
        };
}

function singleton(x, d) {
  return {
          k: x,
          v: d,
          h: 1,
          l: undefined,
          r: undefined
        };
}

function heightGe(l, r) {
  if (r !== undefined) {
    if (l !== undefined) {
      return l.h >= r.h;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

function updateValue(n, newValue) {
  if (n.v === newValue) {
    return n;
  } else {
    return {
            k: n.k,
            v: newValue,
            h: n.h,
            l: n.l,
            r: n.r
          };
  }
}

function bal(l, x, d, r) {
  var hl = l !== undefined ? l.h : 0;
  var hr = r !== undefined ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    var ll = l.l;
    var lr = l.r;
    if (treeHeight(ll) >= treeHeight(lr)) {
      return create(ll, l.k, l.v, create(lr, x, d, r));
    } else {
      return create(create(ll, l.k, l.v, lr.l), lr.k, lr.v, create(lr.r, x, d, r));
    }
  }
  if (hr <= (hl + 2 | 0)) {
    return {
            k: x,
            v: d,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,
            l: l,
            r: r
          };
  }
  var rl = r.l;
  var rr = r.r;
  if (treeHeight(rr) >= treeHeight(rl)) {
    return create(create(l, x, d, rl), r.k, r.v, rr);
  } else {
    return create(create(l, x, d, rl.l), rl.k, rl.v, create(rl.r, r.k, r.v, rr));
  }
}

function minKey0Aux(_n) {
  while(true) {
    var n = _n;
    var n$1 = n.l;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = n$1;
    continue ;
  };
}

function minKey(n) {
  if (n !== undefined) {
    return Caml_option.some(minKey0Aux(n));
  }
  
}

function minKeyUndefined(n) {
  if (n !== undefined) {
    return minKey0Aux(n);
  }
  
}

function maxKey0Aux(_n) {
  while(true) {
    var n = _n;
    var n$1 = n.r;
    if (n$1 === undefined) {
      return n.k;
    }
    _n = n$1;
    continue ;
  };
}

function maxKey(n) {
  if (n !== undefined) {
    return Caml_option.some(maxKey0Aux(n));
  }
  
}

function maxKeyUndefined(n) {
  if (n !== undefined) {
    return maxKey0Aux(n);
  }
  
}

function minKV0Aux(_n) {
  while(true) {
    var n = _n;
    var n$1 = n.l;
    if (n$1 === undefined) {
      return [
              n.k,
              n.v
            ];
    }
    _n = n$1;
    continue ;
  };
}

function minimum(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function minUndefined(n) {
  if (n !== undefined) {
    return minKV0Aux(n);
  }
  
}

function maxKV0Aux(_n) {
  while(true) {
    var n = _n;
    var n$1 = n.r;
    if (n$1 === undefined) {
      return [
              n.k,
              n.v
            ];
    }
    _n = n$1;
    continue ;
  };
}

function maximum(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function maxUndefined(n) {
  if (n !== undefined) {
    return maxKV0Aux(n);
  }
  
}

function removeMinAuxWithRef(n, kr, vr) {
  var ln = n.l;
  if (ln !== undefined) {
    return bal(removeMinAuxWithRef(ln, kr, vr), n.k, n.v, n.r);
  } else {
    kr.contents = n.k;
    vr.contents = n.v;
    return n.r;
  }
}

function isEmpty(x) {
  return x === undefined;
}

function stackAllLeft(_v, _s) {
  while(true) {
    var s = _s;
    var v = _v;
    if (v === undefined) {
      return s;
    }
    _s = {
      hd: v,
      tl: s
    };
    _v = v.l;
    continue ;
  };
}

function findFirstByU(n, p) {
  if (n === undefined) {
    return ;
  }
  var left = findFirstByU(n.l, p);
  if (left !== undefined) {
    return left;
  }
  var v = n.k;
  var d = n.v;
  var pvd = p(v, d);
  if (pvd) {
    return [
            v,
            d
          ];
  }
  var right = findFirstByU(n.r, p);
  if (right !== undefined) {
    return right;
  }
  
}

function findFirstBy(n, p) {
  return findFirstByU(n, Curry.__2(p));
}

function forEachU(_n, f) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return ;
    }
    forEachU(n.l, f);
    f(n.k, n.v);
    _n = n.r;
    continue ;
  };
}

function forEach(n, f) {
  forEachU(n, Curry.__2(f));
}

function mapU(n, f) {
  if (n === undefined) {
    return ;
  }
  var newLeft = mapU(n.l, f);
  var newD = f(n.v);
  var newRight = mapU(n.r, f);
  return {
          k: n.k,
          v: newD,
          h: n.h,
          l: newLeft,
          r: newRight
        };
}

function map(n, f) {
  return mapU(n, Curry.__1(f));
}

function mapWithKeyU(n, f) {
  if (n === undefined) {
    return ;
  }
  var key = n.k;
  var newLeft = mapWithKeyU(n.l, f);
  var newD = f(key, n.v);
  var newRight = mapWithKeyU(n.r, f);
  return {
          k: key,
          v: newD,
          h: n.h,
          l: newLeft,
          r: newRight
        };
}

function mapWithKey(n, f) {
  return mapWithKeyU(n, Curry.__2(f));
}

function reduceU(_m, _accu, f) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (m === undefined) {
      return accu;
    }
    var v = m.k;
    var d = m.v;
    var l = m.l;
    var r = m.r;
    _accu = f(reduceU(l, accu, f), v, d);
    _m = r;
    continue ;
  };
}

function reduce(m, accu, f) {
  return reduceU(m, accu, Curry.__3(f));
}

function everyU(_n, p) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return true;
    }
    if (!p(n.k, n.v)) {
      return false;
    }
    if (!everyU(n.l, p)) {
      return false;
    }
    _n = n.r;
    continue ;
  };
}

function every(n, p) {
  return everyU(n, Curry.__2(p));
}

function someU(_n, p) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return false;
    }
    if (p(n.k, n.v)) {
      return true;
    }
    if (someU(n.l, p)) {
      return true;
    }
    _n = n.r;
    continue ;
  };
}

function some(n, p) {
  return someU(n, Curry.__2(p));
}

function addMinElement(n, k, v) {
  if (n !== undefined) {
    return bal(addMinElement(n.l, k, v), n.k, n.v, n.r);
  } else {
    return singleton(k, v);
  }
}

function addMaxElement(n, k, v) {
  if (n !== undefined) {
    return bal(n.l, n.k, n.v, addMaxElement(n.r, k, v));
  } else {
    return singleton(k, v);
  }
}

function join(ln, v, d, rn) {
  if (ln === undefined) {
    return addMinElement(rn, v, d);
  }
  if (rn === undefined) {
    return addMaxElement(ln, v, d);
  }
  var lv = ln.k;
  var ld = ln.v;
  var lh = ln.h;
  var ll = ln.l;
  var lr = ln.r;
  var rv = rn.k;
  var rd = rn.v;
  var rh = rn.h;
  var rl = rn.l;
  var rr = rn.r;
  if (lh > (rh + 2 | 0)) {
    return bal(ll, lv, ld, join(lr, v, d, rn));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(ln, v, d, rl), rv, rd, rr);
  } else {
    return create(ln, v, d, rn);
  }
}

function concat(t1, t2) {
  if (t1 === undefined) {
    return t2;
  }
  if (t2 === undefined) {
    return t1;
  }
  var kr = {
    contents: t2.k
  };
  var vr = {
    contents: t2.v
  };
  var t2r = removeMinAuxWithRef(t2, kr, vr);
  return join(t1, kr.contents, vr.contents, t2r);
}

function concatOrJoin(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function keepSharedU(n, p) {
  if (n === undefined) {
    return ;
  }
  var v = n.k;
  var d = n.v;
  var newLeft = keepSharedU(n.l, p);
  var pvd = p(v, d);
  var newRight = keepSharedU(n.r, p);
  if (pvd) {
    return join(newLeft, v, d, newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepShared(n, p) {
  return keepSharedU(n, Curry.__2(p));
}

function keepMapU(n, p) {
  if (n === undefined) {
    return ;
  }
  var v = n.k;
  var d = n.v;
  var newLeft = keepMapU(n.l, p);
  var pvd = p(v, d);
  var newRight = keepMapU(n.r, p);
  if (pvd !== undefined) {
    return join(newLeft, v, Caml_option.valFromOption(pvd), newRight);
  } else {
    return concat(newLeft, newRight);
  }
}

function keepMap(n, p) {
  return keepMapU(n, Curry.__2(p));
}

function partitionSharedU(n, p) {
  if (n === undefined) {
    return [
            undefined,
            undefined
          ];
  }
  var key = n.k;
  var value = n.v;
  var match = partitionSharedU(n.l, p);
  var lf = match[1];
  var lt = match[0];
  var pvd = p(key, value);
  var match$1 = partitionSharedU(n.r, p);
  var rf = match$1[1];
  var rt = match$1[0];
  if (pvd) {
    return [
            join(lt, key, value, rt),
            concat(lf, rf)
          ];
  } else {
    return [
            concat(lt, rt),
            join(lf, key, value, rf)
          ];
  }
}

function partitionShared(n, p) {
  return partitionSharedU(n, Curry.__2(p));
}

function lengthNode(n) {
  var l = n.l;
  var r = n.r;
  var sizeL = l !== undefined ? lengthNode(l) : 0;
  var sizeR = r !== undefined ? lengthNode(r) : 0;
  return (1 + sizeL | 0) + sizeR | 0;
}

function size(n) {
  if (n !== undefined) {
    return lengthNode(n);
  } else {
    return 0;
  }
}

function toListAux(_n, _accu) {
  while(true) {
    var accu = _accu;
    var n = _n;
    if (n === undefined) {
      return accu;
    }
    var k = n.k;
    var v = n.v;
    var l = n.l;
    var r = n.r;
    _accu = {
      hd: [
        k,
        v
      ],
      tl: toListAux(r, accu)
    };
    _n = l;
    continue ;
  };
}

function toList(s) {
  return toListAux(s, /* [] */0);
}

function checkInvariantInternal(_v) {
  while(true) {
    var v = _v;
    if (v === undefined) {
      return ;
    }
    var l = v.l;
    var r = v.r;
    var diff = treeHeight(l) - treeHeight(r) | 0;
    if (!(diff <= 2 && diff >= -2)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "belt_internalAVLtree.ml",
              373,
              4
            ],
            Error: new Error()
          };
    }
    checkInvariantInternal(l);
    _v = r;
    continue ;
  };
}

function fillArrayKey(_n, _i, arr) {
  while(true) {
    var i = _i;
    var n = _n;
    var v = n.k;
    var l = n.l;
    var r = n.r;
    var next = l !== undefined ? fillArrayKey(l, i, arr) : i;
    arr[next] = v;
    var rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = r;
    continue ;
  };
}

function fillArrayValue(_n, _i, arr) {
  while(true) {
    var i = _i;
    var n = _n;
    var l = n.l;
    var r = n.r;
    var next = l !== undefined ? fillArrayValue(l, i, arr) : i;
    arr[next] = n.v;
    var rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = r;
    continue ;
  };
}

function fillArray(_n, _i, arr) {
  while(true) {
    var i = _i;
    var n = _n;
    var l = n.l;
    var v = n.k;
    var r = n.r;
    var next = l !== undefined ? fillArray(l, i, arr) : i;
    arr[next] = [
      v,
      n.v
    ];
    var rnext = next + 1 | 0;
    if (r === undefined) {
      return rnext;
    }
    _i = rnext;
    _n = r;
    continue ;
  };
}

function toArray(n) {
  if (n === undefined) {
    return [];
  }
  var size = lengthNode(n);
  var v = new Array(size);
  fillArray(n, 0, v);
  return v;
}

function keysToArray(n) {
  if (n === undefined) {
    return [];
  }
  var size = lengthNode(n);
  var v = new Array(size);
  fillArrayKey(n, 0, v);
  return v;
}

function valuesToArray(n) {
  if (n === undefined) {
    return [];
  }
  var size = lengthNode(n);
  var v = new Array(size);
  fillArrayValue(n, 0, v);
  return v;
}

function fromSortedArrayRevAux(arr, off, len) {
  switch (len) {
    case 0 :
        return ;
    case 1 :
        var match = arr[off];
        return singleton(match[0], match[1]);
    case 2 :
        var match_0 = arr[off];
        var match_1 = arr[off - 1 | 0];
        var match$1 = match_1;
        var match$2 = match_0;
        return {
                k: match$1[0],
                v: match$1[1],
                h: 2,
                l: singleton(match$2[0], match$2[1]),
                r: undefined
              };
    case 3 :
        var match_0$1 = arr[off];
        var match_1$1 = arr[off - 1 | 0];
        var match_2 = arr[off - 2 | 0];
        var match$3 = match_2;
        var match$4 = match_1$1;
        var match$5 = match_0$1;
        return {
                k: match$4[0],
                v: match$4[1],
                h: 2,
                l: singleton(match$5[0], match$5[1]),
                r: singleton(match$3[0], match$3[1])
              };
    default:
      var nl = len / 2 | 0;
      var left = fromSortedArrayRevAux(arr, off, nl);
      var match$6 = arr[off - nl | 0];
      var right = fromSortedArrayRevAux(arr, (off - nl | 0) - 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayAux(arr, off, len) {
  switch (len) {
    case 0 :
        return ;
    case 1 :
        var match = arr[off];
        return singleton(match[0], match[1]);
    case 2 :
        var match_0 = arr[off];
        var match_1 = arr[off + 1 | 0];
        var match$1 = match_1;
        var match$2 = match_0;
        return {
                k: match$1[0],
                v: match$1[1],
                h: 2,
                l: singleton(match$2[0], match$2[1]),
                r: undefined
              };
    case 3 :
        var match_0$1 = arr[off];
        var match_1$1 = arr[off + 1 | 0];
        var match_2 = arr[off + 2 | 0];
        var match$3 = match_2;
        var match$4 = match_1$1;
        var match$5 = match_0$1;
        return {
                k: match$4[0],
                v: match$4[1],
                h: 2,
                l: singleton(match$5[0], match$5[1]),
                r: singleton(match$3[0], match$3[1])
              };
    default:
      var nl = len / 2 | 0;
      var left = fromSortedArrayAux(arr, off, nl);
      var match$6 = arr[off + nl | 0];
      var right = fromSortedArrayAux(arr, (off + nl | 0) + 1 | 0, (len - nl | 0) - 1 | 0);
      return create(left, match$6[0], match$6[1], right);
  }
}

function fromSortedArrayUnsafe(arr) {
  return fromSortedArrayAux(arr, 0, arr.length);
}

function cmpU(s1, s2, kcmp, vcmp) {
  var len1 = size(s1);
  var len2 = size(s2);
  if (len1 === len2) {
    var _e1 = stackAllLeft(s1, /* [] */0);
    var _e2 = stackAllLeft(s2, /* [] */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        return 0;
      }
      if (!e2) {
        return 0;
      }
      var h2 = e2.hd;
      var h1 = e1.hd;
      var c = kcmp(h1.k, h2.k);
      if (c !== 0) {
        return c;
      }
      var cx = vcmp(h1.v, h2.v);
      if (cx !== 0) {
        return cx;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue ;
    };
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, kcmp, vcmp) {
  return cmpU(s1, s2, kcmp, Curry.__2(vcmp));
}

function eqU(s1, s2, kcmp, veq) {
  var len1 = size(s1);
  var len2 = size(s2);
  if (len1 === len2) {
    var _e1 = stackAllLeft(s1, /* [] */0);
    var _e2 = stackAllLeft(s2, /* [] */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        return true;
      }
      if (!e2) {
        return true;
      }
      var h2 = e2.hd;
      var h1 = e1.hd;
      if (!(kcmp(h1.k, h2.k) === 0 && veq(h1.v, h2.v))) {
        return false;
      }
      _e2 = stackAllLeft(h2.r, e2.tl);
      _e1 = stackAllLeft(h1.r, e1.tl);
      continue ;
    };
  } else {
    return false;
  }
}

function eq(s1, s2, kcmp, veq) {
  return eqU(s1, s2, kcmp, Curry.__2(veq));
}

function get(_n, x, cmp) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return ;
    }
    var v = n.k;
    var c = cmp(x, v);
    if (c === 0) {
      return Caml_option.some(n.v);
    }
    _n = c < 0 ? n.l : n.r;
    continue ;
  };
}

function getUndefined(_n, x, cmp) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return ;
    }
    var v = n.k;
    var c = cmp(x, v);
    if (c === 0) {
      return n.v;
    }
    _n = c < 0 ? n.l : n.r;
    continue ;
  };
}

function getExn(_n, x, cmp) {
  while(true) {
    var n = _n;
    if (n !== undefined) {
      var v = n.k;
      var c = cmp(x, v);
      if (c === 0) {
        return n.v;
      }
      _n = c < 0 ? n.l : n.r;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function getWithDefault(_n, x, def, cmp) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return def;
    }
    var v = n.k;
    var c = cmp(x, v);
    if (c === 0) {
      return n.v;
    }
    _n = c < 0 ? n.l : n.r;
    continue ;
  };
}

function has(_n, x, cmp) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return false;
    }
    var v = n.k;
    var c = cmp(x, v);
    if (c === 0) {
      return true;
    }
    _n = c < 0 ? n.l : n.r;
    continue ;
  };
}

function rotateWithLeftChild(k2) {
  var k1 = k2.l;
  k2.l = k1.r;
  k1.r = k2;
  var hlk2 = treeHeight(k2.l);
  var hrk2 = treeHeight(k2.r);
  k2.h = (
    hlk2 > hrk2 ? hlk2 : hrk2
  ) + 1 | 0;
  var hlk1 = treeHeight(k1.l);
  var hk2 = k2.h;
  k1.h = (
    hlk1 > hk2 ? hlk1 : hk2
  ) + 1 | 0;
  return k1;
}

function rotateWithRightChild(k1) {
  var k2 = k1.r;
  k1.r = k2.l;
  k2.l = k1;
  var hlk1 = treeHeight(k1.l);
  var hrk1 = treeHeight(k1.r);
  k1.h = (
    hlk1 > hrk1 ? hlk1 : hrk1
  ) + 1 | 0;
  var hrk2 = treeHeight(k2.r);
  var hk1 = k1.h;
  k2.h = (
    hrk2 > hk1 ? hrk2 : hk1
  ) + 1 | 0;
  return k2;
}

function doubleWithLeftChild(k3) {
  var x = k3.l;
  var v = rotateWithRightChild(x);
  k3.l = v;
  return rotateWithLeftChild(k3);
}

function doubleWithRightChild(k2) {
  var x = k2.r;
  var v = rotateWithLeftChild(x);
  k2.r = v;
  return rotateWithRightChild(k2);
}

function heightUpdateMutate(t) {
  var hlt = treeHeight(t.l);
  var hrt = treeHeight(t.r);
  t.h = (
    hlt > hrt ? hlt : hrt
  ) + 1 | 0;
  return t;
}

function balMutate(nt) {
  var l = nt.l;
  var r = nt.r;
  var hl = treeHeight(l);
  var hr = treeHeight(r);
  if (hl > (2 + hr | 0)) {
    var ll = l.l;
    var lr = l.r;
    if (heightGe(ll, lr)) {
      return heightUpdateMutate(rotateWithLeftChild(nt));
    } else {
      return heightUpdateMutate(doubleWithLeftChild(nt));
    }
  }
  if (hr > (2 + hl | 0)) {
    var rl = r.l;
    var rr = r.r;
    if (heightGe(rr, rl)) {
      return heightUpdateMutate(rotateWithRightChild(nt));
    } else {
      return heightUpdateMutate(doubleWithRightChild(nt));
    }
  }
  nt.h = (
    hl > hr ? hl : hr
  ) + 1 | 0;
  return nt;
}

function updateMutate(t, x, data, cmp) {
  if (t === undefined) {
    return singleton(x, data);
  }
  var k = t.k;
  var c = cmp(x, k);
  if (c === 0) {
    t.v = data;
    return t;
  }
  var l = t.l;
  var r = t.r;
  if (c < 0) {
    var ll = updateMutate(l, x, data, cmp);
    t.l = ll;
  } else {
    t.r = updateMutate(r, x, data, cmp);
  }
  return balMutate(t);
}

function fromArray(xs, cmp) {
  var len = xs.length;
  if (len === 0) {
    return ;
  }
  var next = Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
          return cmp(param[0], param$1[0]) < 0;
        }));
  var result;
  if (next >= 0) {
    result = fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for(var i = next; i < len; ++i){
    var match = xs[i];
    result = updateMutate(result, match[0], match[1], cmp);
  }
  return result;
}

function removeMinAuxWithRootMutate(nt, n) {
  var rn = n.r;
  var ln = n.l;
  if (ln !== undefined) {
    n.l = removeMinAuxWithRootMutate(nt, ln);
    return balMutate(n);
  } else {
    nt.k = n.k;
    nt.v = n.v;
    return rn;
  }
}

exports.copy = copy;
exports.create = create;
exports.bal = bal;
exports.singleton = singleton;
exports.updateValue = updateValue;
exports.minKey = minKey;
exports.minKeyUndefined = minKeyUndefined;
exports.maxKey = maxKey;
exports.maxKeyUndefined = maxKeyUndefined;
exports.minimum = minimum;
exports.minUndefined = minUndefined;
exports.maximum = maximum;
exports.maxUndefined = maxUndefined;
exports.removeMinAuxWithRef = removeMinAuxWithRef;
exports.isEmpty = isEmpty;
exports.stackAllLeft = stackAllLeft;
exports.findFirstByU = findFirstByU;
exports.findFirstBy = findFirstBy;
exports.forEachU = forEachU;
exports.forEach = forEach;
exports.mapU = mapU;
exports.map = map;
exports.mapWithKeyU = mapWithKeyU;
exports.mapWithKey = mapWithKey;
exports.reduceU = reduceU;
exports.reduce = reduce;
exports.everyU = everyU;
exports.every = every;
exports.someU = someU;
exports.some = some;
exports.join = join;
exports.concat = concat;
exports.concatOrJoin = concatOrJoin;
exports.keepSharedU = keepSharedU;
exports.keepShared = keepShared;
exports.keepMapU = keepMapU;
exports.keepMap = keepMap;
exports.partitionSharedU = partitionSharedU;
exports.partitionShared = partitionShared;
exports.lengthNode = lengthNode;
exports.size = size;
exports.toList = toList;
exports.checkInvariantInternal = checkInvariantInternal;
exports.fillArray = fillArray;
exports.toArray = toArray;
exports.keysToArray = keysToArray;
exports.valuesToArray = valuesToArray;
exports.fromSortedArrayAux = fromSortedArrayAux;
exports.fromSortedArrayRevAux = fromSortedArrayRevAux;
exports.fromSortedArrayUnsafe = fromSortedArrayUnsafe;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqU = eqU;
exports.eq = eq;
exports.get = get;
exports.getUndefined = getUndefined;
exports.getWithDefault = getWithDefault;
exports.getExn = getExn;
exports.has = has;
exports.fromArray = fromArray;
exports.updateMutate = updateMutate;
exports.balMutate = balMutate;
exports.removeMinAuxWithRootMutate = removeMinAuxWithRootMutate;
/* No side effect */

},{"./belt_SortArray.js":23,"./caml_option.js":33,"./curry.js":37}],25:[function(require,module,exports){
'use strict';

var Caml = require("./caml.js");
var Curry = require("./curry.js");
var Caml_option = require("./caml_option.js");
var Belt_SortArray = require("./belt_SortArray.js");
var Belt_internalAVLtree = require("./belt_internalAVLtree.js");

function add(t, x, data) {
  if (t === undefined) {
    return Belt_internalAVLtree.singleton(x, data);
  }
  var k = t.k;
  if (x === k) {
    return Belt_internalAVLtree.updateValue(t, data);
  }
  var v = t.v;
  if (x < k) {
    return Belt_internalAVLtree.bal(add(t.l, x, data), k, v, t.r);
  } else {
    return Belt_internalAVLtree.bal(t.l, k, v, add(t.r, x, data));
  }
}

function get(_n, x) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return ;
    }
    var v = n.k;
    if (x === v) {
      return Caml_option.some(n.v);
    }
    _n = x < v ? n.l : n.r;
    continue ;
  };
}

function getUndefined(_n, x) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return ;
    }
    var v = n.k;
    if (x === v) {
      return n.v;
    }
    _n = x < v ? n.l : n.r;
    continue ;
  };
}

function getExn(_n, x) {
  while(true) {
    var n = _n;
    if (n !== undefined) {
      var v = n.k;
      if (x === v) {
        return n.v;
      }
      _n = x < v ? n.l : n.r;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function getWithDefault(_n, x, def) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return def;
    }
    var v = n.k;
    if (x === v) {
      return n.v;
    }
    _n = x < v ? n.l : n.r;
    continue ;
  };
}

function has(_n, x) {
  while(true) {
    var n = _n;
    if (n === undefined) {
      return false;
    }
    var v = n.k;
    if (x === v) {
      return true;
    }
    _n = x < v ? n.l : n.r;
    continue ;
  };
}

function remove(n, x) {
  if (n === undefined) {
    return n;
  }
  var v = n.k;
  var l = n.l;
  var r = n.r;
  if (x !== v) {
    if (x < v) {
      return Belt_internalAVLtree.bal(remove(l, x), v, n.v, r);
    } else {
      return Belt_internalAVLtree.bal(l, v, n.v, remove(r, x));
    }
  }
  if (l === undefined) {
    return r;
  }
  if (r === undefined) {
    return l;
  }
  var kr = {
    contents: r.k
  };
  var vr = {
    contents: r.v
  };
  var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);
  return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);
}

function splitAux(x, n) {
  var v = n.k;
  var d = n.v;
  var l = n.l;
  var r = n.r;
  if (x === v) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (x < v) {
    if (l === undefined) {
      return [
              undefined,
              undefined,
              n
            ];
    }
    var match = splitAux(x, l);
    return [
            match[0],
            match[1],
            Belt_internalAVLtree.join(match[2], v, d, r)
          ];
  }
  if (r === undefined) {
    return [
            n,
            undefined,
            undefined
          ];
  }
  var match$1 = splitAux(x, r);
  return [
          Belt_internalAVLtree.join(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function split(x, n) {
  if (n !== undefined) {
    return splitAux(x, n);
  } else {
    return [
            undefined,
            undefined,
            undefined
          ];
  }
}

function mergeU(s1, s2, f) {
  if (s1 !== undefined) {
    if (s1.h >= (
        s2 !== undefined ? s2.h : 0
      )) {
      var v1 = s1.k;
      var d1 = s1.v;
      var l1 = s1.l;
      var r1 = s1.r;
      var match = split(v1, s2);
      return Belt_internalAVLtree.concatOrJoin(mergeU(l1, match[0], f), v1, f(v1, Caml_option.some(d1), match[1]), mergeU(r1, match[2], f));
    }
    
  } else if (s2 === undefined) {
    return ;
  }
  var v2 = s2.k;
  var d2 = s2.v;
  var l2 = s2.l;
  var r2 = s2.r;
  var match$1 = split(v2, s1);
  return Belt_internalAVLtree.concatOrJoin(mergeU(match$1[0], l2, f), v2, f(v2, match$1[1], Caml_option.some(d2)), mergeU(match$1[2], r2, f));
}

function merge(s1, s2, f) {
  return mergeU(s1, s2, Curry.__3(f));
}

function compareAux(_e1, _e2, vcmp) {
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (!e1) {
      return 0;
    }
    if (!e2) {
      return 0;
    }
    var h2 = e2.hd;
    var h1 = e1.hd;
    var c = Caml.string_compare(h1.k, h2.k);
    if (c !== 0) {
      return c;
    }
    var cx = vcmp(h1.v, h2.v);
    if (cx !== 0) {
      return cx;
    }
    _e2 = Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue ;
  };
}

function cmpU(s1, s2, cmp) {
  var len1 = Belt_internalAVLtree.size(s1);
  var len2 = Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return compareAux(Belt_internalAVLtree.stackAllLeft(s1, /* [] */0), Belt_internalAVLtree.stackAllLeft(s2, /* [] */0), cmp);
  } else if (len1 < len2) {
    return -1;
  } else {
    return 1;
  }
}

function cmp(s1, s2, f) {
  return cmpU(s1, s2, Curry.__2(f));
}

function eqAux(_e1, _e2, eq) {
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (!e1) {
      return true;
    }
    if (!e2) {
      return true;
    }
    var h2 = e2.hd;
    var h1 = e1.hd;
    if (!(h1.k === h2.k && eq(h1.v, h2.v))) {
      return false;
    }
    _e2 = Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);
    _e1 = Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);
    continue ;
  };
}

function eqU(s1, s2, eq) {
  var len1 = Belt_internalAVLtree.size(s1);
  var len2 = Belt_internalAVLtree.size(s2);
  if (len1 === len2) {
    return eqAux(Belt_internalAVLtree.stackAllLeft(s1, /* [] */0), Belt_internalAVLtree.stackAllLeft(s2, /* [] */0), eq);
  } else {
    return false;
  }
}

function eq(s1, s2, f) {
  return eqU(s1, s2, Curry.__2(f));
}

function addMutate(t, x, data) {
  if (t === undefined) {
    return Belt_internalAVLtree.singleton(x, data);
  }
  var k = t.k;
  if (x === k) {
    t.k = x;
    t.v = data;
    return t;
  }
  var l = t.l;
  var r = t.r;
  if (x < k) {
    var ll = addMutate(l, x, data);
    t.l = ll;
  } else {
    t.r = addMutate(r, x, data);
  }
  return Belt_internalAVLtree.balMutate(t);
}

function fromArray(xs) {
  var len = xs.length;
  if (len === 0) {
    return ;
  }
  var next = Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {
          return param[0] < param$1[0];
        }));
  var result;
  if (next >= 0) {
    result = Belt_internalAVLtree.fromSortedArrayAux(xs, 0, next);
  } else {
    next = -next | 0;
    result = Belt_internalAVLtree.fromSortedArrayRevAux(xs, next - 1 | 0, next);
  }
  for(var i = next; i < len; ++i){
    var match = xs[i];
    result = addMutate(result, match[0], match[1]);
  }
  return result;
}

var N;

var A;

var S;

exports.N = N;
exports.A = A;
exports.S = S;
exports.add = add;
exports.get = get;
exports.getUndefined = getUndefined;
exports.getExn = getExn;
exports.getWithDefault = getWithDefault;
exports.has = has;
exports.remove = remove;
exports.splitAux = splitAux;
exports.split = split;
exports.mergeU = mergeU;
exports.merge = merge;
exports.compareAux = compareAux;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.eqAux = eqAux;
exports.eqU = eqU;
exports.eq = eq;
exports.addMutate = addMutate;
exports.fromArray = fromArray;
/* No side effect */

},{"./belt_SortArray.js":23,"./belt_internalAVLtree.js":24,"./caml.js":26,"./caml_option.js":33,"./curry.js":37}],26:[function(require,module,exports){
'use strict';


function int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function i64_eq(x, y) {
  if (x[1] === y[1]) {
    return x[0] === y[0];
  } else {
    return false;
  }
}

function i64_ge(param, param$1) {
  var other_hi = param$1[0];
  var hi = param[0];
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param[1] >= param$1[1];
  }
}

function i64_neq(x, y) {
  return !i64_eq(x, y);
}

function i64_lt(x, y) {
  return !i64_ge(x, y);
}

function i64_gt(x, y) {
  if (x[0] > y[0]) {
    return true;
  } else if (x[0] < y[0]) {
    return false;
  } else {
    return x[1] > y[1];
  }
}

function i64_le(x, y) {
  return !i64_gt(x, y);
}

function i64_min(x, y) {
  if (i64_ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function i64_max(x, y) {
  if (i64_gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

exports.int_compare = int_compare;
exports.bool_compare = bool_compare;
exports.float_compare = float_compare;
exports.string_compare = string_compare;
exports.bool_min = bool_min;
exports.int_min = int_min;
exports.float_min = float_min;
exports.string_min = string_min;
exports.bool_max = bool_max;
exports.int_max = int_max;
exports.float_max = float_max;
exports.string_max = string_max;
exports.i64_eq = i64_eq;
exports.i64_neq = i64_neq;
exports.i64_lt = i64_lt;
exports.i64_gt = i64_gt;
exports.i64_le = i64_le;
exports.i64_ge = i64_ge;
exports.i64_min = i64_min;
exports.i64_max = i64_max;
/* No side effect */

},{}],27:[function(require,module,exports){
'use strict';


function sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (!l) {
      return acc;
    }
    _l = l.tl;
    _acc = l.hd.length + acc | 0;
    continue ;
  };
}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    var l$1 = x.length;
    var k = i;
    var j = 0;
    while(j < l$1) {
      arr[k] = x[j];
      k = k + 1 | 0;
      j = j + 1 | 0;
    };
    _l = l.tl;
    _i = k;
    continue ;
  };
}

function concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  xs[index] = newval;
}

function get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return xs[index];
}

function make(len, init) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = init;
  }
  return b;
}

function make_float(len) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = 0;
  }
  return b;
}

function blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0; j < len; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return ;
  }
  for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
  }
}

function dup(prim) {
  return prim.slice(0);
}

exports.dup = dup;
exports.sub = sub;
exports.concat = concat;
exports.make = make;
exports.make_float = make_float;
exports.blit = blit;
exports.get = get;
exports.set = set;
/* No side effect */

},{}],28:[function(require,module,exports){
'use strict';


var id = {
  contents: 0
};

function create(str) {
  id.contents = id.contents + 1 | 0;
  return str + ("/" + id.contents);
}

function is_extension(e) {
  if (e == null) {
    return false;
  } else {
    return typeof e.RE_EXN_ID === "string";
  }
}

function exn_slot_name(x) {
  return x.RE_EXN_ID;
}

exports.id = id;
exports.create = create;
exports.is_extension = is_extension;
exports.exn_slot_name = exn_slot_name;
/* No side effect */

},{}],29:[function(require,module,exports){
'use strict';

var Caml = require("./caml.js");
var Caml_int64 = require("./caml_int64.js");

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* '0' */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    case /* Bin */3 :
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  var match = s.codePointAt(i);
  switch (match) {
    case 43 :
        i = i + 1 | 0;
        break;
    case 44 :
        break;
    case 45 :
        sign = -1;
        i = i + 1 | 0;
        break;
    default:
      
  }
  if (s.codePointAt(i) === /* '0' */48) {
    var match$1 = s.codePointAt(i + 1 | 0);
    if (match$1 >= 89) {
      if (match$1 >= 111) {
        if (match$1 < 121) {
          switch (match$1) {
            case 111 :
                base = /* Oct */0;
                i = i + 2 | 0;
                break;
            case 117 :
                i = i + 2 | 0;
                break;
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
                break;
            case 120 :
                base = /* Hex */1;
                i = i + 2 | 0;
                break;
            
          }
        }
        
      } else if (match$1 === 98) {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
      
    } else if (match$1 !== 66) {
      if (match$1 >= 79) {
        switch (match$1) {
          case 79 :
              base = /* Oct */0;
              i = i + 2 | 0;
              break;
          case 85 :
              i = i + 2 | 0;
              break;
          case 80 :
          case 81 :
          case 82 :
          case 83 :
          case 84 :
          case 86 :
          case 87 :
              break;
          case 88 :
              base = /* Hex */1;
              i = i + 2 | 0;
              break;
          
        }
      }
      
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return [
          i,
          sign,
          base
        ];
}

function int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.codePointAt(i) : /* '\000' */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.codePointAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = parse_digit(a);
      if (v < 0 || v >= base) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      var acc$1 = base * acc + v;
      if (acc$1 > threshold) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    };
  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = Caml_int64.of_int32(int_of_string_base(hbase));
  var sign = Caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case /* Oct */0 :
        threshold = [
          536870911,
          4294967295
        ];
        break;
    case /* Hex */1 :
        threshold = [
          268435455,
          4294967295
        ];
        break;
    case /* Dec */2 :
        threshold = [
          429496729,
          2576980377
        ];
        break;
    case /* Bin */3 :
        threshold = Caml_int64.max_int;
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.codePointAt(i) : /* '\000' */0;
  var d = Caml_int64.of_int32(parse_digit(c));
  if (Caml.i64_lt(d, Caml_int64.zero) || Caml.i64_ge(d, base)) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.codePointAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = Caml_int64.of_int32(parse_digit(a));
      if (Caml.i64_lt(v, Caml_int64.zero) || Caml.i64_ge(v, base) || Caml.i64_gt(acc, threshold)) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int64_of_string",
              Error: new Error()
            };
      }
      var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    };
  };
  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = Caml_int64.or_(res, Caml_int64.zero);
  if (Caml.i64_eq(base, [
          0,
          10
        ]) && Caml.i64_neq(res, or_res)) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    
  }
}

function lowercase(c) {
  if (c >= /* 'A' */65 && c <= /* 'Z' */90 || c >= /* '\192' */192 && c <= /* '\214' */214 || c >= /* '\216' */216 && c <= /* '\222' */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "format_int: format too long",
          Error: new Error()
        };
  }
  var f = {
    justify: "+",
    signstyle: "-",
    filter: " ",
    alternate: false,
    base: /* Dec */2,
    signedconv: false,
    width: 0,
    uppercase: false,
    sign: 1,
    prec: -1,
    conv: "f"
  };
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    }
    var c = fmt.codePointAt(i);
    var exit = 0;
    if (c >= 69) {
      if (c >= 88) {
        if (c >= 121) {
          exit = 1;
        } else {
          switch (c) {
            case 88 :
                f.base = /* Hex */1;
                f.uppercase = true;
                _i = i + 1 | 0;
                continue ;
            case 101 :
            case 102 :
            case 103 :
                exit = 5;
                break;
            case 100 :
            case 105 :
                exit = 4;
                break;
            case 111 :
                f.base = /* Oct */0;
                _i = i + 1 | 0;
                continue ;
            case 117 :
                f.base = /* Dec */2;
                _i = i + 1 | 0;
                continue ;
            case 89 :
            case 90 :
            case 91 :
            case 92 :
            case 93 :
            case 94 :
            case 95 :
            case 96 :
            case 97 :
            case 98 :
            case 99 :
            case 104 :
            case 106 :
            case 107 :
            case 108 :
            case 109 :
            case 110 :
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
                exit = 1;
                break;
            case 120 :
                f.base = /* Hex */1;
                _i = i + 1 | 0;
                continue ;
            
          }
        }
      } else if (c >= 72) {
        exit = 1;
      } else {
        f.signedconv = true;
        f.uppercase = true;
        f.conv = String.fromCharCode(lowercase(c));
        _i = i + 1 | 0;
        continue ;
      }
    } else {
      switch (c) {
        case 35 :
            f.alternate = true;
            _i = i + 1 | 0;
            continue ;
        case 32 :
        case 43 :
            exit = 2;
            break;
        case 45 :
            f.justify = "-";
            _i = i + 1 | 0;
            continue ;
        case 46 :
            f.prec = 0;
            var j = i + 1 | 0;
            while((function(j){
                return function () {
                  var w = fmt.codePointAt(j) - /* '0' */48 | 0;
                  return w >= 0 && w <= 9;
                }
                }(j))()) {
              f.prec = (Math.imul(f.prec, 10) + fmt.codePointAt(j) | 0) - /* '0' */48 | 0;
              j = j + 1 | 0;
            };
            _i = j;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 47 :
            exit = 1;
            break;
        case 48 :
            f.filter = "0";
            _i = i + 1 | 0;
            continue ;
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            exit = 3;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          _i = i + 1 | 0;
          continue ;
      case 2 :
          f.signstyle = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      case 3 :
          f.width = 0;
          var j$1 = i;
          while((function(j$1){
              return function () {
                var w = fmt.codePointAt(j$1) - /* '0' */48 | 0;
                return w >= 0 && w <= 9;
              }
              }(j$1))()) {
            f.width = (Math.imul(f.width, 10) + fmt.codePointAt(j$1) | 0) - /* '0' */48 | 0;
            j$1 = j$1 + 1 | 0;
          };
          _i = j$1;
          continue ;
      case 4 :
          f.signedconv = true;
          f.base = /* Dec */2;
          _i = i + 1 | 0;
          continue ;
      case 5 :
          f.signedconv = true;
          f.conv = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      
    }
  };
}

function finish_formatting(config, rawbuffer) {
  var justify = config.justify;
  var signstyle = config.signstyle;
  var filter = config.filter;
  var alternate = config.alternate;
  var base = config.base;
  var signedconv = config.signedconv;
  var width = config.width;
  var uppercase = config.uppercase;
  var sign = config.sign;
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base === /* Oct */0) {
      len = len + 1 | 0;
    } else if (base === /* Hex */1) {
      len = len + 2 | 0;
    }
    
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var _for = len; _for < width; ++_for){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var _for$1 = len; _for$1 < width; ++_for$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var _for$2 = len; _for$2 < width; ++_for$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  }
  var f = parse_format(fmt);
  var i$1 = i < 0 ? (
      f.signedconv ? (f.sign = -1, (-i >>> 0)) : (i >>> 0)
    ) : i;
  var s = i$1.toString(int_of_base(f.base));
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    if (n > 0) {
      s = "0".repeat(n) + s;
    }
    
  }
  return finish_formatting(f, s);
}

function dec_of_pos_int64(x) {
  if (!Caml.i64_lt(x, Caml_int64.zero)) {
    return Caml_int64.to_string(x);
  }
  var wbase = [
    0,
    10
  ];
  var y = Caml_int64.discard_sign(x);
  var match = Caml_int64.div_mod(y, wbase);
  var match$1 = Caml_int64.div_mod(Caml_int64.add([
            0,
            8
          ], match[1]), wbase);
  var quotient = Caml_int64.add(Caml_int64.add([
            214748364,
            3435973836
          ], match[0]), match$1[0]);
  return Caml_int64.to_string(quotient) + "0123456789"[Caml_int64.to_int32(match$1[1])];
}

function oct_of_int64(x) {
  var s = "";
  var wbase = [
    0,
    8
  ];
  var cvtbl = "01234567";
  if (Caml.i64_lt(x, Caml_int64.zero)) {
    var y = Caml_int64.discard_sign(x);
    var match = Caml_int64.div_mod(y, wbase);
    var quotient = Caml_int64.add([
          268435456,
          0
        ], match[0]);
    var modulus = match[1];
    s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    while(Caml.i64_neq(quotient, Caml_int64.zero)) {
      var match$1 = Caml_int64.div_mod(quotient, wbase);
      quotient = match$1[0];
      modulus = match$1[1];
      s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    };
  } else {
    var match$2 = Caml_int64.div_mod(x, wbase);
    var quotient$1 = match$2[0];
    var modulus$1 = match$2[1];
    s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    while(Caml.i64_neq(quotient$1, Caml_int64.zero)) {
      var match$3 = Caml_int64.div_mod(quotient$1, wbase);
      quotient$1 = match$3[0];
      modulus$1 = match$3[1];
      s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    };
  }
  return s;
}

function int64_format(fmt, x) {
  if (fmt === "%d") {
    return Caml_int64.to_string(x);
  }
  var f = parse_format(fmt);
  var x$1 = f.signedconv && Caml.i64_lt(x, Caml_int64.zero) ? (f.sign = -1, Caml_int64.neg(x)) : x;
  var match = f.base;
  var s;
  switch (match) {
    case /* Oct */0 :
        s = oct_of_int64(x$1);
        break;
    case /* Hex */1 :
        s = Caml_int64.to_hex(x$1);
        break;
    case /* Dec */2 :
        s = dec_of_pos_int64(x$1);
        break;
    
  }
  var fill_s;
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    fill_s = n > 0 ? "0".repeat(n) + s : s;
  } else {
    fill_s = s;
  }
  return finish_formatting(f, fill_s);
}

function format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f.prec < 0 ? 6 : f.prec;
  var x$1 = x < 0 ? (f.sign = -1, -x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f.filter = " ";
  } else if (isFinite(x$1)) {
    var match = f.conv;
    switch (match) {
      case "e" :
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s.codePointAt(i - 3 | 0) === /* 'e' */101) {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" :
          s = x$1.toFixed(prec);
          break;
      case "g" :
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s.codePointAt(i$1) === /* '0' */48) {
              i$1 = i$1 - 1 | 0;
            };
            if (s.codePointAt(i$1) === /* '.' */46) {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s.codePointAt(i$2 - 3 | 0) === /* 'e' */101) {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return s.length > (prec$1 + 1 | 0);
                    })()) {
                p = p - 1 | 0;
              };
            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s.codePointAt(k) === /* '0' */48) {
                k = k - 1 | 0;
              };
              if (s.codePointAt(k) === /* '.' */46) {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
      default:
        
    }
  } else {
    s = "inf";
    f.filter = " ";
  }
  return finish_formatting(f, s);
}

var hexstring_of_float = (function(x,prec,style){
  if (!isFinite(x)) {
    if (isNaN(x)) return "nan";
    return x > 0 ? "infinity":"-infinity";
  }
  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;
  if(sign) x = -x;
  var exp = 0;
  if (x == 0) { }
  else if (x < 1) {
    while (x < 1 && exp > -1022)  { x *= 2; exp-- }
  } else {
    while (x >= 2) { x /= 2; exp++ }
  }
  var exp_sign = exp < 0 ? '' : '+';
  var sign_str = '';
  if (sign) sign_str = '-'
  else {
    switch(style){
    case 43 /* '+' */: sign_str = '+'; break;
    case 32 /* ' ' */: sign_str = ' '; break;
    default: break;
    }
  }
  if (prec >= 0 && prec < 13) {
    /* If a precision is given, and is small, round mantissa accordingly */
      var cst = Math.pow(2,prec * 4);
      x = Math.round(x * cst) / cst;
  }
  var x_str = x.toString(16);
  if(prec >= 0){
      var idx = x_str.indexOf('.');
    if(idx<0) {
      x_str += '.' +  '0'.repeat(prec);
    }
    else {
      var size = idx+1+prec;
      if(x_str.length < size)
        x_str += '0'.repeat(size - x_str.length);
      else
        x_str = x_str.substr(0,size);
    }
  }
  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));
});

var float_of_string = (function(s,exn){

    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    };
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
    //            1        2             3           4
    if(m){
        var m3 = m[3].replace(/0+$/,'');
        var mantissa = parseInt(m[1] + m[2] + m3, 16);
        var exponent = (m[4]|0) - 4*m3.length;
        res = mantissa * Math.pow(2, exponent);
        return res;
    }
    if (/^\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    throw exn;
});

function float_of_string$1(s) {
  return float_of_string(s, {
              RE_EXN_ID: "Failure",
              _1: "float_of_string"
            });
}

exports.format_float = format_float;
exports.hexstring_of_float = hexstring_of_float;
exports.format_int = format_int;
exports.float_of_string = float_of_string$1;
exports.int64_format = int64_format;
exports.int_of_string = int_of_string;
exports.int64_of_string = int64_of_string;
/* No side effect */

},{"./caml.js":26,"./caml_int64.js":30}],30:[function(require,module,exports){
'use strict';

var Caml = require("./caml.js");

function mk(lo, hi) {
  return [
          hi,
          (lo >>> 0)
        ];
}

var min_int = [
  -2147483648,
  0
];

var max_int = [
  2147483647,
  4294967295
];

var one = [
  0,
  1
];

var zero = [
  0,
  0
];

var neg_one = [
  -1,
  4294967295
];

function neg_signed(x) {
  return (x & -2147483648) !== 0;
}

function non_neg_signed(x) {
  return (x & -2147483648) === 0;
}

function succ(param) {
  var x_lo = param[1];
  var x_hi = param[0];
  var lo = x_lo + 1 | 0;
  return [
          x_hi + (
            lo === 0 ? 1 : 0
          ) | 0,
          (lo >>> 0)
        ];
}

function neg(param) {
  var other_lo = (param[1] ^ -1) + 1 | 0;
  return [
          (param[0] ^ -1) + (
            other_lo === 0 ? 1 : 0
          ) | 0,
          (other_lo >>> 0)
        ];
}

function add_aux(param, y_lo, y_hi) {
  var x_lo = param[1];
  var lo = x_lo + y_lo | 0;
  var overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;
  return [
          param[0] + y_hi + overflow | 0,
          (lo >>> 0)
        ];
}

function add(self, param) {
  return add_aux(self, param[1], param[0]);
}

function equal(x, y) {
  if (x[1] === y[1]) {
    return x[0] === y[0];
  } else {
    return false;
  }
}

function equal_null(x, y) {
  if (y !== null) {
    return Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return false;
  } else {
    return Caml.i64_eq(x, y);
  }
}

function sub_aux(x, lo, hi) {
  var y_lo = ((lo ^ -1) + 1 >>> 0);
  var y_hi = (hi ^ -1) + (
    y_lo === 0 ? 1 : 0
  ) | 0;
  return add_aux(x, y_lo, y_hi);
}

function sub(self, param) {
  return sub_aux(self, param[1], param[0]);
}

function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var lo = x[1];
  if (numBits >= 32) {
    return [
            (lo << (numBits - 32 | 0)),
            0
          ];
  } else {
    return [
            (lo >>> (32 - numBits | 0)) | (x[0] << numBits),
            ((lo << numBits) >>> 0)
          ];
  }
}

function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  var offset = numBits - 32 | 0;
  if (offset === 0) {
    return [
            0,
            (hi >>> 0)
          ];
  } else if (offset > 0) {
    return [
            0,
            (hi >>> offset)
          ];
  } else {
    return [
            (hi >>> numBits),
            (((hi << (-offset | 0)) | (x[1] >>> numBits)) >>> 0)
          ];
  }
}

function asr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  if (numBits < 32) {
    return [
            (hi >> numBits),
            (((hi << (32 - numBits | 0)) | (x[1] >>> numBits)) >>> 0)
          ];
  } else {
    return [
            hi >= 0 ? 0 : -1,
            ((hi >> (numBits - 32 | 0)) >>> 0)
          ];
  }
}

function is_zero(param) {
  if (param[0] !== 0) {
    return false;
  } else {
    return param[1] === 0;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var lo;
    var this_hi = $$this[0];
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (this_hi !== 0) {
      exit$2 = 4;
    } else {
      if ($$this[1] === 0) {
        return zero;
      }
      exit$2 = 4;
    }
    if (exit$2 === 4) {
      if (other[0] !== 0) {
        exit$1 = 3;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      if (this_hi !== -2147483648 || $$this[1] !== 0) {
        exit = 2;
      } else {
        lo = other[1];
      }
    }
    if (exit === 2) {
      var other_hi = other[0];
      var lo$1 = $$this[1];
      var exit$3 = 0;
      if (other_hi !== -2147483648 || other[1] !== 0) {
        exit$3 = 3;
      } else {
        lo = lo$1;
      }
      if (exit$3 === 3) {
        var other_lo = other[1];
        if (this_hi < 0) {
          if (other_hi >= 0) {
            return neg(mul(neg($$this), other));
          }
          _other = neg(other);
          _this = neg($$this);
          continue ;
        }
        if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        }
        var a48 = (this_hi >>> 16);
        var a32 = this_hi & 65535;
        var a16 = (lo$1 >>> 16);
        var a00 = lo$1 & 65535;
        var b48 = (other_hi >>> 16);
        var b32 = other_hi & 65535;
        var b16 = (other_lo >>> 16);
        var b00 = other_lo & 65535;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = a00 * b00;
        c16 = (c00 >>> 16) + a16 * b00;
        c32 = (c16 >>> 16);
        c16 = (c16 & 65535) + a00 * b16;
        c32 = c32 + (c16 >>> 16) + a32 * b00;
        c48 = (c32 >>> 16);
        c32 = (c32 & 65535) + a16 * b16;
        c48 = c48 + (c32 >>> 16);
        c32 = (c32 & 65535) + a00 * b32;
        c48 = c48 + (c32 >>> 16);
        c32 = c32 & 65535;
        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
        return [
                c32 | (c48 << 16),
                ((c00 & 65535 | ((c16 & 65535) << 16)) >>> 0)
              ];
      }
      
    }
    if ((lo & 1) === 0) {
      return zero;
    } else {
      return min_int;
    }
  };
}

function xor(param, param$1) {
  return [
          param[0] ^ param$1[0],
          ((param[1] ^ param$1[1]) >>> 0)
        ];
}

function or_(param, param$1) {
  return [
          param[0] | param$1[0],
          ((param[1] | param$1[1]) >>> 0)
        ];
}

function and_(param, param$1) {
  return [
          param[0] & param$1[0],
          ((param[1] & param$1[1]) >>> 0)
        ];
}

function to_float(param) {
  return param[0] * 0x100000000 + param[1];
}

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  }
  if (x <= -9.22337203685477581e+18) {
    return min_int;
  }
  if (x + 1 >= 9.22337203685477581e+18) {
    return max_int;
  }
  if (x < 0) {
    return neg(of_float(-x));
  }
  var hi = x / 4294967296 | 0;
  var lo = x % 4294967296 | 0;
  return [
          hi,
          (lo >>> 0)
        ];
}

function isSafeInteger(param) {
  var hi = param[0];
  var top11Bits = (hi >> 21);
  if (top11Bits === 0) {
    return true;
  } else if (top11Bits === -1) {
    return !(param[1] === 0 && hi === -2097152);
  } else {
    return false;
  }
}

function to_string(self) {
  if (isSafeInteger(self)) {
    return String(to_float(self));
  }
  if (self[0] < 0) {
    if (Caml.i64_eq(self, min_int)) {
      return "-9223372036854775808";
    } else {
      return "-" + to_string(neg(self));
    }
  }
  var approx_div1 = of_float(Math.floor(to_float(self) / 10));
  var lo = approx_div1[1];
  var hi = approx_div1[0];
  var match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));
  var rem_lo = match[1];
  var rem_hi = match[0];
  if (rem_lo === 0 && rem_hi === 0) {
    return to_string(approx_div1) + "0";
  }
  if (rem_hi < 0) {
    var rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);
    var delta = Math.ceil(rem_lo$1 / 10);
    var remainder = 10 * delta - rem_lo$1;
    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);
  }
  var delta$1 = Math.floor(rem_lo / 10);
  var remainder$1 = rem_lo - 10 * delta$1;
  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);
}

function div(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var self_hi = self[0];
    var exit = 0;
    var exit$1 = 0;
    if (other[0] !== 0 || other[1] !== 0) {
      exit$1 = 2;
    } else {
      throw {
            RE_EXN_ID: "Division_by_zero",
            Error: new Error()
          };
    }
    if (exit$1 === 2) {
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit = 1;
        } else {
          if (self[1] === 0) {
            return zero;
          }
          exit = 1;
        }
      } else if (self[1] !== 0) {
        exit = 1;
      } else {
        if (Caml.i64_eq(other, one) || Caml.i64_eq(other, neg_one)) {
          return self;
        }
        if (Caml.i64_eq(other, min_int)) {
          return one;
        }
        var half_this = asr_(self, 1);
        var approx = lsl_(div(half_this, other), 1);
        var exit$2 = 0;
        if (approx[0] !== 0) {
          exit$2 = 3;
        } else {
          if (approx[1] === 0) {
            if (other[0] < 0) {
              return one;
            } else {
              return neg(one);
            }
          }
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          var rem = sub(self, mul(other, approx));
          return add(approx, div(rem, other));
        }
        
      }
    }
    if (exit === 1) {
      var other_hi = other[0];
      var exit$3 = 0;
      if (other_hi !== -2147483648) {
        exit$3 = 2;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$3 = 2;
      }
      if (exit$3 === 2) {
        if (self_hi < 0) {
          if (other_hi >= 0) {
            return neg(div(neg(self), other));
          }
          _other = neg(other);
          _self = neg(self);
          continue ;
        }
        if (other_hi < 0) {
          return neg(div(self, neg(other)));
        }
        var res = zero;
        var rem$1 = self;
        while(Caml.i64_ge(rem$1, other)) {
          var b = Math.floor(to_float(rem$1) / to_float(other));
          var approx$1 = 1 > b ? 1 : b;
          var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
          var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          var approxRes = of_float(approx$1);
          var approxRem = mul(approxRes, other);
          while(approxRem[0] < 0 || Caml.i64_gt(approxRem, rem$1)) {
            approx$1 = approx$1 - delta;
            approxRes = of_float(approx$1);
            approxRem = mul(approxRes, other);
          };
          if (is_zero(approxRes)) {
            approxRes = one;
          }
          res = add(res, approxRes);
          rem$1 = sub(rem$1, approxRem);
        };
        return res;
      }
      
    }
    
  };
}

function mod_(self, other) {
  return sub(self, mul(div(self, other), other));
}

function div_mod(self, other) {
  var quotient = div(self, other);
  return [
          quotient,
          sub(self, mul(quotient, other))
        ];
}

function compare(self, other) {
  var y = other[0];
  var x = self[0];
  var v = x < y ? -1 : (
      x === y ? 0 : 1
    );
  if (v !== 0) {
    return v;
  }
  var y$1 = other[1];
  var x$1 = self[1];
  if (x$1 < y$1) {
    return -1;
  } else if (x$1 === y$1) {
    return 0;
  } else {
    return 1;
  }
}

function of_int32(lo) {
  return [
          lo < 0 ? -1 : 0,
          (lo >>> 0)
        ];
}

function to_int32(x) {
  return x[1] | 0;
}

function to_hex(x) {
  var x_lo = x[1];
  var x_hi = x[0];
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  if (x_hi === 0 && x_lo === 0) {
    return "0";
  }
  if (x_lo === 0) {
    return aux(x_hi) + "00000000";
  }
  if (x_hi === 0) {
    return aux(x_lo);
  }
  var lo = aux(x_lo);
  var pad = 8 - lo.length | 0;
  if (pad <= 0) {
    return aux(x_hi) + lo;
  } else {
    return aux(x_hi) + ("0".repeat(pad) + lo);
  }
}

function discard_sign(x) {
  return [
          2147483647 & x[0],
          x[1]
        ];
}

function float_of_bits(x) {
  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]})(x[1], x[0]);
}

function bits_of_float(x) {
  var match = (function(x){return new Int32Array(new Float64Array([x]).buffer)})(x);
  return [
          match[1],
          (match[0] >>> 0)
        ];
}

exports.mk = mk;
exports.succ = succ;
exports.min_int = min_int;
exports.max_int = max_int;
exports.one = one;
exports.zero = zero;
exports.neg_one = neg_one;
exports.of_int32 = of_int32;
exports.to_int32 = to_int32;
exports.add = add;
exports.neg = neg;
exports.sub = sub;
exports.lsl_ = lsl_;
exports.lsr_ = lsr_;
exports.asr_ = asr_;
exports.is_zero = is_zero;
exports.mul = mul;
exports.xor = xor;
exports.or_ = or_;
exports.and_ = and_;
exports.equal = equal;
exports.equal_null = equal_null;
exports.equal_undefined = equal_undefined;
exports.equal_nullable = equal_nullable;
exports.to_float = to_float;
exports.of_float = of_float;
exports.div = div;
exports.mod_ = mod_;
exports.compare = compare;
exports.float_of_bits = float_of_bits;
exports.bits_of_float = bits_of_float;
exports.div_mod = div_mod;
exports.to_hex = to_hex;
exports.discard_sign = discard_sign;
exports.to_string = to_string;
/* No side effect */

},{"./caml.js":26}],31:[function(require,module,exports){
'use strict';

var Caml_option = require("./caml_option.js");
var Caml_exceptions = require("./caml_exceptions.js");

var $$Error = "JsError";

function internalToOCamlException(e) {
  if (Caml_exceptions.is_extension(e)) {
    return e;
  } else {
    return {
            RE_EXN_ID: "JsError",
            _1: e
          };
  }
}

function as_js_exn(exn) {
  if (exn.RE_EXN_ID === $$Error) {
    return Caml_option.some(exn._1);
  }
  
}

exports.$$Error = $$Error;
exports.internalToOCamlException = internalToOCamlException;
exports.as_js_exn = as_js_exn;
/* No side effect */

},{"./caml_exceptions.js":28,"./caml_option.js":33}],32:[function(require,module,exports){
'use strict';

var Caml = require("./caml.js");

var for_in = (function(o,foo){
        for (var x in o) { foo(x) }});

var obj_dup = (function(x){
  if(Array.isArray(x)){
    var len = x.length  
    var v = new Array(len)
    for(var i = 0 ; i < len ; ++i){
      v[i] = x[i]
    }
    if(x.TAG !== undefined){
      v.TAG = x.TAG // TODO this can be removed eventually
    }  
    return v 
  } 
  return Object.assign({},x)    
});

var update_dummy = (function(x,y){
  var k  
  if(Array.isArray(y)){
    for(k = 0; k < y.length ; ++k){
      x[k] = y[k]
    }
    if(y.TAG !== undefined){
      x.TAG = y.TAG
    }
  } else {
    for (var k in y){
      x[k] = y[k]
    }
  }
});

function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var a_type = typeof a;
  var b_type = typeof b;
  switch (a_type) {
    case "boolean" :
        if (b_type === "boolean") {
          return Caml.bool_compare(a, b);
        }
        break;
    case "function" :
        if (b_type === "function") {
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: "compare: functional value",
                Error: new Error()
              };
        }
        break;
    case "number" :
        if (b_type === "number") {
          return Caml.int_compare(a, b);
        }
        break;
    case "string" :
        if (b_type === "string") {
          return Caml.string_compare(a, b);
        } else {
          return 1;
        }
    case "undefined" :
        return -1;
    default:
      
  }
  switch (b_type) {
    case "string" :
        return -1;
    case "undefined" :
        return 1;
    default:
      if (a_type === "boolean") {
        return 1;
      }
      if (b_type === "boolean") {
        return -1;
      }
      if (a_type === "function") {
        return 1;
      }
      if (b_type === "function") {
        return -1;
      }
      if (a_type === "number") {
        if (b === null || b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b_type === "number") {
        if (a === null || a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a === null) {
        if (b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b === null) {
        if (a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
        if (b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return aux_obj_compare(a, b);
        } else {
          return -1;
        }
      }
      var tag_a = a.TAG | 0;
      var tag_b = b.TAG | 0;
      if (tag_a === 248) {
        return Caml.int_compare(a[1], b[1]);
      }
      if (tag_a === 251) {
        throw {
              RE_EXN_ID: "Invalid_argument",
              _1: "equal: abstract value",
              Error: new Error()
            };
      }
      if (tag_a !== tag_b) {
        if (tag_a < tag_b) {
          return -1;
        } else {
          return 1;
        }
      }
      var len_a = a.length | 0;
      var len_b = b.length | 0;
      if (len_a === len_b) {
        if (Array.isArray(a)) {
          var _i = 0;
          while(true) {
            var i = _i;
            if (i === len_a) {
              return 0;
            }
            var res = compare(a[i], b[i]);
            if (res !== 0) {
              return res;
            }
            _i = i + 1 | 0;
            continue ;
          };
        } else if ((a instanceof Date && b instanceof Date)) {
          return (a - b);
        } else {
          return aux_obj_compare(a, b);
        }
      } else if (len_a < len_b) {
        var _i$1 = 0;
        while(true) {
          var i$1 = _i$1;
          if (i$1 === len_a) {
            return -1;
          }
          var res$1 = compare(a[i$1], b[i$1]);
          if (res$1 !== 0) {
            return res$1;
          }
          _i$1 = i$1 + 1 | 0;
          continue ;
        };
      } else {
        var _i$2 = 0;
        while(true) {
          var i$2 = _i$2;
          if (i$2 === len_b) {
            return 1;
          }
          var res$2 = compare(a[i$2], b[i$2]);
          if (res$2 !== 0) {
            return res$2;
          }
          _i$2 = i$2 + 1 | 0;
          continue ;
        };
      }
  }
}

function aux_obj_compare(a, b) {
  var min_key_lhs = {
    contents: undefined
  };
  var min_key_rhs = {
    contents: undefined
  };
  var do_key = function (param, key) {
    var min_key = param[2];
    var b = param[1];
    if (!(!Object.prototype.hasOwnProperty.call(b, key) || compare(param[0][key], b[key]) > 0)) {
      return ;
    }
    var mk = min_key.contents;
    if (mk !== undefined && key >= mk) {
      return ;
    } else {
      min_key.contents = key;
      return ;
    }
  };
  var partial_arg = [
    a,
    b,
    min_key_rhs
  ];
  var do_key_a = function (param) {
    return do_key(partial_arg, param);
  };
  var partial_arg$1 = [
    b,
    a,
    min_key_lhs
  ];
  var do_key_b = function (param) {
    return do_key(partial_arg$1, param);
  };
  for_in(a, do_key_a);
  for_in(b, do_key_b);
  var match = min_key_lhs.contents;
  var match$1 = min_key_rhs.contents;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return Caml.string_compare(match, match$1);
    } else {
      return -1;
    }
  } else if (match$1 !== undefined) {
    return 1;
  } else {
    return 0;
  }
}

function equal(a, b) {
  if (a === b) {
    return true;
  }
  var a_type = typeof a;
  if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
    return false;
  }
  var b_type = typeof b;
  if (a_type === "function" || b_type === "function") {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "equal: functional value",
          Error: new Error()
        };
  }
  if (b_type === "number" || b_type === "undefined" || b === null) {
    return false;
  }
  var tag_a = a.TAG | 0;
  var tag_b = b.TAG | 0;
  if (tag_a === 248) {
    return a[1] === b[1];
  }
  if (tag_a === 251) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "equal: abstract value",
          Error: new Error()
        };
  }
  if (tag_a !== tag_b) {
    return false;
  }
  var len_a = a.length | 0;
  var len_b = b.length | 0;
  if (len_a === len_b) {
    if (Array.isArray(a)) {
      var _i = 0;
      while(true) {
        var i = _i;
        if (i === len_a) {
          return true;
        }
        if (!equal(a[i], b[i])) {
          return false;
        }
        _i = i + 1 | 0;
        continue ;
      };
    } else if ((a instanceof Date && b instanceof Date)) {
      return !(a > b || a < b);
    } else {
      var result = {
        contents: true
      };
      var do_key_a = function (key) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) {
          result.contents = false;
          return ;
        }
        
      };
      var do_key_b = function (key) {
        if (!Object.prototype.hasOwnProperty.call(a, key) || !equal(b[key], a[key])) {
          result.contents = false;
          return ;
        }
        
      };
      for_in(a, do_key_a);
      if (result.contents) {
        for_in(b, do_key_b);
      }
      return result.contents;
    }
  } else {
    return false;
  }
}

function equal_null(x, y) {
  if (y !== null) {
    return equal(x, y);
  } else {
    return x === y;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return equal(x, y);
  } else {
    return x === y;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return x === y;
  } else {
    return equal(x, y);
  }
}

function notequal(a, b) {
  return !equal(a, b);
}

function greaterequal(a, b) {
  return compare(a, b) >= 0;
}

function greaterthan(a, b) {
  return compare(a, b) > 0;
}

function lessequal(a, b) {
  return compare(a, b) <= 0;
}

function lessthan(a, b) {
  return compare(a, b) < 0;
}

function min(x, y) {
  if (compare(x, y) <= 0) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (compare(x, y) >= 0) {
    return x;
  } else {
    return y;
  }
}

exports.obj_dup = obj_dup;
exports.update_dummy = update_dummy;
exports.compare = compare;
exports.equal = equal;
exports.equal_null = equal_null;
exports.equal_undefined = equal_undefined;
exports.equal_nullable = equal_nullable;
exports.notequal = notequal;
exports.greaterequal = greaterequal;
exports.greaterthan = greaterthan;
exports.lessthan = lessthan;
exports.lessequal = lessequal;
exports.min = min;
exports.max = max;
/* No side effect */

},{"./caml.js":26}],33:[function(require,module,exports){
'use strict';


function isNested(x) {
  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;
}

function some(x) {
  if (x === undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: 0
          };
  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0
          };
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x == null) {
    return ;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return ;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {
    return x;
  }
  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return ;
  } else {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
          };
  }
}

function option_get(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x);
  }
}

function option_unwrap(x) {
  if (x !== undefined) {
    return x.VAL;
  } else {
    return x;
  }
}

exports.nullable_to_opt = nullable_to_opt;
exports.undefined_to_opt = undefined_to_opt;
exports.null_to_opt = null_to_opt;
exports.valFromOption = valFromOption;
exports.some = some;
exports.isNested = isNested;
exports.option_get = option_get;
exports.option_unwrap = option_unwrap;
/* No side effect */

},{}],34:[function(require,module,exports){
'use strict';


var spliceApply = (function(fn,args){
  var i, argLen; 
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return fn.apply(null,applied)
});

var spliceNewApply = (function (ctor,args){
  var i, argLen;
  argLen = args.length
  var applied = [null] // Function.prototype.bind.apply(fn, args) requires the first element in `args` to be `null`
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  var C = Function.prototype.bind.apply(ctor, applied)
  return new C()
});

var spliceObjApply = (function(obj,name,args){
  var i, argLen; 
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return (obj[name]).apply(obj,applied)
});

exports.spliceApply = spliceApply;
exports.spliceNewApply = spliceNewApply;
exports.spliceObjApply = spliceObjApply;
/* No side effect */

},{}],35:[function(require,module,exports){
'use strict';


function get(s, i) {
  if (i >= s.length || i < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return s.codePointAt(i);
}

function make(n, ch) {
  return String.fromCharCode(ch).repeat(n);
}

exports.get = get;
exports.make = make;
/* No side effect */

},{}],36:[function(require,module,exports){
(function (process){(function (){
'use strict';


function sys_getenv(s) {
  if (typeof process === "undefined" || process.env === undefined) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var x = process.env[s];
  if (x !== undefined) {
    return x;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var os_type = (function(_){
  if(typeof process !== 'undefined' && process.platform === 'win32'){
        return "Win32"    
  }
  else {
    return "Unix"
  }
});

function sys_time(param) {
  if (typeof process === "undefined" || process.uptime === undefined) {
    return -1;
  } else {
    return process.uptime();
  }
}

var sys_getcwd = (function(param){
    if (typeof process === "undefined" || process.cwd === undefined){
      return "/"  
    }
    return process.cwd()
  });

function sys_get_argv(param) {
  if (typeof process === "undefined") {
    return [
            "",
            [""]
          ];
  }
  var argv = process.argv;
  if (argv == null) {
    return [
            "",
            [""]
          ];
  } else {
    return [
            argv[0],
            argv
          ];
  }
}

function sys_exit(exit_code) {
  if (typeof process !== "undefined") {
    return process.exit(exit_code);
  }
  
}

function sys_is_directory(_s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: "sys_is_directory not implemented",
        Error: new Error()
      };
}

function sys_file_exists(_s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: "sys_file_exists not implemented",
        Error: new Error()
      };
}

exports.sys_getenv = sys_getenv;
exports.sys_time = sys_time;
exports.os_type = os_type;
exports.sys_getcwd = sys_getcwd;
exports.sys_get_argv = sys_get_argv;
exports.sys_exit = sys_exit;
exports.sys_is_directory = sys_is_directory;
exports.sys_file_exists = sys_file_exists;
/* No side effect */

}).call(this)}).call(this,require('_process'))
},{"_process":47}],37:[function(require,module,exports){
'use strict';

var Caml_array = require("./caml_array.js");

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return (function(f,args){
      return function (x) {
        return app(f, args.concat([x]));
      }
      }(f,args));
    }
    _args = Caml_array.sub(args, arity, -d | 0);
    _f = f.apply(null, Caml_array.sub(args, 0, arity));
    continue ;
  };
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1 :
          return o(a0);
      case 2 :
          return function (param) {
            return o(a0, param);
          };
      case 3 :
          return function (param, param$1) {
            return o(a0, param, param$1);
          };
      case 4 :
          return function (param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          };
      case 5 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          };
      case 6 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          };
      default:
        return app(o, [a0]);
    }
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function (a0) {
      return _1(o, a0);
    };
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [a1]);
      case 2 :
          return o(a0, a1);
      case 3 :
          return function (param) {
            return o(a0, a1, param);
          };
      case 4 :
          return function (param, param$1) {
            return o(a0, a1, param, param$1);
          };
      case 5 :
          return function (param, param$1, param$2) {
            return o(a0, a1, param, param$1, param$2);
          };
      case 6 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, param, param$1, param$2, param$3);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, a1, param, param$1, param$2, param$3, param$4);
          };
      default:
        return app(o, [
                    a0,
                    a1
                  ]);
    }
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function (a0, a1) {
      return _2(o, a0, a1);
    };
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2
                    ]);
      case 2 :
          return app(o(a0, a1), [a2]);
      case 3 :
          return o(a0, a1, a2);
      case 4 :
          return function (param) {
            return o(a0, a1, a2, param);
          };
      case 5 :
          return function (param, param$1) {
            return o(a0, a1, a2, param, param$1);
          };
      case 6 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          };
      case 7 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2
                  ]);
    }
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function (a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [a3]);
      case 4 :
          return o(a0, a1, a2, a3);
      case 5 :
          return function (param) {
            return o(a0, a1, a2, a3, param);
          };
      case 6 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, param, param$1);
          };
      case 7 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, a3, param, param$1, param$2);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3
                  ]);
    }
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function (a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [a4]);
      case 5 :
          return o(a0, a1, a2, a3, a4);
      case 6 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, param);
          };
      case 7 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, a4, param, param$1);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4
                  ]);
    }
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6 :
          return o(a0, a1, a2, a3, a4, a5);
      case 7 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, a5, param);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    }
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7 :
          return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    }
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6,
                      a7
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [
                      a6,
                      a7
                    ]);
      case 7 :
          return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    }
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

exports.app = app;
exports._1 = _1;
exports.__1 = __1;
exports._2 = _2;
exports.__2 = __2;
exports._3 = _3;
exports.__3 = __3;
exports._4 = _4;
exports.__4 = __4;
exports._5 = _5;
exports.__5 = __5;
exports._6 = _6;
exports.__6 = __6;
exports._7 = _7;
exports.__7 = __7;
exports._8 = _8;
exports.__8 = __8;
/* No side effect */

},{"./caml_array.js":27}],38:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_option = require("./caml_option.js");
var Caml_splice_call = require("./caml_splice_call.js");

function copyWithin(to_, obj) {
  return obj.copyWithin(to_);
}

function copyWithinFrom(to_, from, obj) {
  return obj.copyWithin(to_, from);
}

function copyWithinFromRange(to_, start, end_, obj) {
  return obj.copyWithin(to_, start, end_);
}

function fillInPlace(arg1, obj) {
  return obj.fill(arg1);
}

function fillFromInPlace(arg1, from, obj) {
  return obj.fill(arg1, from);
}

function fillRangeInPlace(arg1, start, end_, obj) {
  return obj.fill(arg1, start, end_);
}

function push(arg1, obj) {
  return obj.push(arg1);
}

function pushMany(arg1, obj) {
  return Caml_splice_call.spliceObjApply(obj, "push", [arg1]);
}

function sortInPlaceWith(arg1, obj) {
  return obj.sort(Curry.__2(arg1));
}

function spliceInPlace(pos, remove, add, obj) {
  return Caml_splice_call.spliceObjApply(obj, "splice", [
              pos,
              remove,
              add
            ]);
}

function removeFromInPlace(pos, obj) {
  return obj.splice(pos);
}

function removeCountInPlace(pos, count, obj) {
  return obj.splice(pos, count);
}

function unshift(arg1, obj) {
  return obj.unshift(arg1);
}

function unshiftMany(arg1, obj) {
  return Caml_splice_call.spliceObjApply(obj, "unshift", [arg1]);
}

function concat(arg1, obj) {
  return obj.concat(arg1);
}

function concatMany(arg1, obj) {
  return Caml_splice_call.spliceObjApply(obj, "concat", [arg1]);
}

function includes(arg1, obj) {
  return obj.includes(arg1);
}

function indexOf(arg1, obj) {
  return obj.indexOf(arg1);
}

function indexOfFrom(arg1, from, obj) {
  return obj.indexOf(arg1, from);
}

function joinWith(arg1, obj) {
  return obj.join(arg1);
}

function lastIndexOf(arg1, obj) {
  return obj.lastIndexOf(arg1);
}

function lastIndexOfFrom(arg1, from, obj) {
  return obj.lastIndexOf(arg1, from);
}

function slice(start, end_, obj) {
  return obj.slice(start, end_);
}

function sliceFrom(arg1, obj) {
  return obj.slice(arg1);
}

function every(arg1, obj) {
  return obj.every(Curry.__1(arg1));
}

function everyi(arg1, obj) {
  return obj.every(Curry.__2(arg1));
}

function filter(arg1, obj) {
  return obj.filter(Curry.__1(arg1));
}

function filteri(arg1, obj) {
  return obj.filter(Curry.__2(arg1));
}

function find(arg1, obj) {
  return Caml_option.undefined_to_opt(obj.find(Curry.__1(arg1)));
}

function findi(arg1, obj) {
  return Caml_option.undefined_to_opt(obj.find(Curry.__2(arg1)));
}

function findIndex(arg1, obj) {
  return obj.findIndex(Curry.__1(arg1));
}

function findIndexi(arg1, obj) {
  return obj.findIndex(Curry.__2(arg1));
}

function forEach(arg1, obj) {
  obj.forEach(Curry.__1(arg1));
}

function forEachi(arg1, obj) {
  obj.forEach(Curry.__2(arg1));
}

function map(arg1, obj) {
  return obj.map(Curry.__1(arg1));
}

function mapi(arg1, obj) {
  return obj.map(Curry.__2(arg1));
}

function reduce(arg1, arg2, obj) {
  return obj.reduce(Curry.__2(arg1), arg2);
}

function reducei(arg1, arg2, obj) {
  return obj.reduce(Curry.__3(arg1), arg2);
}

function reduceRight(arg1, arg2, obj) {
  return obj.reduceRight(Curry.__2(arg1), arg2);
}

function reduceRighti(arg1, arg2, obj) {
  return obj.reduceRight(Curry.__3(arg1), arg2);
}

function some(arg1, obj) {
  return obj.some(Curry.__1(arg1));
}

function somei(arg1, obj) {
  return obj.some(Curry.__2(arg1));
}

exports.copyWithin = copyWithin;
exports.copyWithinFrom = copyWithinFrom;
exports.copyWithinFromRange = copyWithinFromRange;
exports.fillInPlace = fillInPlace;
exports.fillFromInPlace = fillFromInPlace;
exports.fillRangeInPlace = fillRangeInPlace;
exports.push = push;
exports.pushMany = pushMany;
exports.sortInPlaceWith = sortInPlaceWith;
exports.spliceInPlace = spliceInPlace;
exports.removeFromInPlace = removeFromInPlace;
exports.removeCountInPlace = removeCountInPlace;
exports.unshift = unshift;
exports.unshiftMany = unshiftMany;
exports.concat = concat;
exports.concatMany = concatMany;
exports.includes = includes;
exports.indexOf = indexOf;
exports.indexOfFrom = indexOfFrom;
exports.joinWith = joinWith;
exports.lastIndexOf = lastIndexOf;
exports.lastIndexOfFrom = lastIndexOfFrom;
exports.slice = slice;
exports.sliceFrom = sliceFrom;
exports.every = every;
exports.everyi = everyi;
exports.filter = filter;
exports.filteri = filteri;
exports.find = find;
exports.findi = findi;
exports.findIndex = findIndex;
exports.findIndexi = findIndexi;
exports.forEach = forEach;
exports.forEachi = forEachi;
exports.map = map;
exports.mapi = mapi;
exports.reduce = reduce;
exports.reducei = reducei;
exports.reduceRight = reduceRight;
exports.reduceRighti = reduceRighti;
exports.some = some;
exports.somei = somei;
/* No side effect */

},{"./caml_option.js":33,"./caml_splice_call.js":34,"./curry.js":37}],39:[function(require,module,exports){
'use strict';

var Caml_option = require("./caml_option.js");

function get(dict, k) {
  if ((k in dict)) {
    return Caml_option.some(dict[k]);
  }
  
}

var unsafeDeleteKey = (function (dict,key){
      delete dict[key];
     });

function entries(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = new Array(l);
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    values[i] = [
      key,
      dict[key]
    ];
  }
  return values;
}

function values(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values$1 = new Array(l);
  for(var i = 0; i < l; ++i){
    values$1[i] = dict[keys[i]];
  }
  return values$1;
}

function fromList(entries) {
  var dict = {};
  var _param = entries;
  while(true) {
    var param = _param;
    if (!param) {
      return dict;
    }
    var match = param.hd;
    dict[match[0]] = match[1];
    _param = param.tl;
    continue ;
  };
}

function fromArray(entries) {
  var dict = {};
  var l = entries.length;
  for(var i = 0; i < l; ++i){
    var match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

function map(f, source) {
  var target = {};
  var keys = Object.keys(source);
  var l = keys.length;
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    target[key] = f(source[key]);
  }
  return target;
}

exports.get = get;
exports.unsafeDeleteKey = unsafeDeleteKey;
exports.entries = entries;
exports.values = values;
exports.fromList = fromList;
exports.fromArray = fromArray;
exports.map = map;
/* No side effect */

},{"./caml_option.js":33}],40:[function(require,module,exports){
'use strict';


function equal(x, y) {
  return x === y;
}

var max = 2147483647;

var min = -2147483648;

exports.equal = equal;
exports.max = max;
exports.min = min;
/* No side effect */

},{}],41:[function(require,module,exports){
'use strict';

var Caml_option = require("./caml_option.js");

function classify(x) {
  var ty = typeof x;
  if (ty === "string") {
    return {
            TAG: /* JSONString */0,
            _0: x
          };
  } else if (ty === "number") {
    return {
            TAG: /* JSONNumber */1,
            _0: x
          };
  } else if (ty === "boolean") {
    if (x === true) {
      return /* JSONTrue */1;
    } else {
      return /* JSONFalse */0;
    }
  } else if (x === null) {
    return /* JSONNull */2;
  } else if (Array.isArray(x)) {
    return {
            TAG: /* JSONArray */3,
            _0: x
          };
  } else {
    return {
            TAG: /* JSONObject */2,
            _0: x
          };
  }
}

function test(x, v) {
  switch (v) {
    case /* String */0 :
        return typeof x === "string";
    case /* Number */1 :
        return typeof x === "number";
    case /* Object */2 :
        if (x !== null && typeof x === "object") {
          return !Array.isArray(x);
        } else {
          return false;
        }
    case /* Array */3 :
        return Array.isArray(x);
    case /* Boolean */4 :
        return typeof x === "boolean";
    case /* Null */5 :
        return x === null;
    
  }
}

function decodeString(json) {
  if (typeof json === "string") {
    return json;
  }
  
}

function decodeNumber(json) {
  if (typeof json === "number") {
    return json;
  }
  
}

function decodeObject(json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    return Caml_option.some(json);
  }
  
}

function decodeArray(json) {
  if (Array.isArray(json)) {
    return json;
  }
  
}

function decodeBoolean(json) {
  if (typeof json === "boolean") {
    return json;
  }
  
}

function decodeNull(json) {
  if (json === null) {
    return null;
  }
  
}

var patch = (function (json) {
  var x = [json];
  var q = [{ kind: 0, i: 0, parent: x }];
  while (q.length !== 0) {
    // begin pop the stack
    var cur = q[q.length - 1];
    if (cur.kind === 0) {
      cur.val = cur.parent[cur.i]; // patch the undefined value for array
      if (++cur.i === cur.parent.length) {
        q.pop();
      }
    } else {
      q.pop();
    }
    // finish
    var task = cur.val;
    if (typeof task === "object") {
      if (Array.isArray(task) && task.length !== 0) {
        q.push({ kind: 0, i: 0, parent: task, val: undefined });
      } else {
        for (var k in task) {
          if (k === "RE_PRIVATE_NONE") {
            if (cur.kind === 0) {
              cur.parent[cur.i - 1] = undefined;
            } else {
              cur.parent[cur.i] = undefined;
            }
            continue;
          }
          q.push({ kind: 1, i: k, parent: task, val: task[k] });
        }
      }
    }
  }
  return x[0];
});

function serializeExn(x) {
  return (function(obj){
  var output= JSON.stringify(obj,function(_,value){
      if(value===undefined){
          return {RE_PRIVATE_NONE : true}
      }
    return value
  });
  
 if(output === undefined){
   // JSON.stringify will raise TypeError when it detects cylic objects
   throw new TypeError("output is undefined")
 }
 return output 
 })(x);
}

function deserializeUnsafe(s) {
  return patch(JSON.parse(s));
}

exports.classify = classify;
exports.test = test;
exports.decodeString = decodeString;
exports.decodeNumber = decodeNumber;
exports.decodeObject = decodeObject;
exports.decodeArray = decodeArray;
exports.decodeBoolean = decodeBoolean;
exports.decodeNull = decodeNull;
exports.deserializeUnsafe = deserializeUnsafe;
exports.serializeExn = serializeExn;
/* No side effect */

},{"./caml_option.js":33}],42:[function(require,module,exports){
'use strict';

var Js_int = require("./js_int.js");

function unsafe_ceil(prim) {
  return Math.ceil(prim);
}

function ceil_int(f) {
  if (f > Js_int.max) {
    return Js_int.max;
  } else if (f < Js_int.min) {
    return Js_int.min;
  } else {
    return Math.ceil(f);
  }
}

function unsafe_floor(prim) {
  return Math.floor(prim);
}

function floor_int(f) {
  if (f > Js_int.max) {
    return Js_int.max;
  } else if (f < Js_int.min) {
    return Js_int.min;
  } else {
    return Math.floor(f);
  }
}

function random_int(min, max) {
  return floor_int(Math.random() * (max - min | 0)) + min | 0;
}

var ceil = ceil_int;

var floor = floor_int;

exports.unsafe_ceil = unsafe_ceil;
exports.ceil_int = ceil_int;
exports.ceil = ceil;
exports.unsafe_floor = unsafe_floor;
exports.floor_int = floor_int;
exports.floor = floor;
exports.random_int = random_int;
/* No side effect */

},{"./js_int.js":40}],43:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_obj = require("./caml_obj.js");
var Pervasives = require("./pervasives.js");
var Caml_option = require("./caml_option.js");

function length(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (!param) {
      return len;
    }
    _param = param.tl;
    _len = len + 1 | 0;
    continue ;
  };
}

function cons(a, l) {
  return {
          hd: a,
          tl: l
        };
}

function hd(param) {
  if (param) {
    return param.hd;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "hd",
        Error: new Error()
      };
}

function tl(param) {
  if (param) {
    return param.tl;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "tl",
        Error: new Error()
      };
}

function nth(l, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1.hd;
      }
      _n = n$1 - 1 | 0;
      _l = l$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "nth",
          Error: new Error()
        };
  };
}

function nth_opt(l, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (!l$1) {
      return ;
    }
    if (n$1 === 0) {
      return Caml_option.some(l$1.hd);
    }
    _n = n$1 - 1 | 0;
    _l = l$1.tl;
    continue ;
  };
}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  };
}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function init_tailrec_aux(_acc, _i, n, f) {
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i >= n) {
      return acc;
    }
    _i = i + 1 | 0;
    _acc = {
      hd: Curry._1(f, i),
      tl: acc
    };
    continue ;
  };
}

function init_aux(i, n, f) {
  if (i >= n) {
    return /* [] */0;
  }
  var r = Curry._1(f, i);
  return {
          hd: r,
          tl: init_aux(i + 1 | 0, n, f)
        };
}

function init(len, f) {
  if (len < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.init",
          Error: new Error()
        };
  }
  if (len > 10000) {
    return rev_append(init_tailrec_aux(/* [] */0, 0, len, f), /* [] */0);
  } else {
    return init_aux(0, len, f);
  }
}

function flatten(param) {
  if (param) {
    return Pervasives.$at(param.hd, flatten(param.tl));
  } else {
    return /* [] */0;
  }
}

function map(f, param) {
  if (!param) {
    return /* [] */0;
  }
  var r = Curry._1(f, param.hd);
  return {
          hd: r,
          tl: map(f, param.tl)
        };
}

function mapi(i, f, param) {
  if (!param) {
    return /* [] */0;
  }
  var r = Curry._2(f, i, param.hd);
  return {
          hd: r,
          tl: mapi(i + 1 | 0, f, param.tl)
        };
}

function mapi$1(f, l) {
  return mapi(0, f, l);
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: Curry._1(f, param.hd),
      tl: accu
    };
    continue ;
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    Curry._1(f, param.hd);
    _param = param.tl;
    continue ;
  };
}

function iteri(f, l) {
  var _i = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return ;
    }
    Curry._2(f, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (!l) {
      return accu;
    }
    _l = l.tl;
    _accu = Curry._2(f, accu, l.hd);
    continue ;
  };
}

function fold_right(f, l, accu) {
  if (l) {
    return Curry._2(f, l.hd, fold_right(f, l.tl, accu));
  } else {
    return accu;
  }
}

function map2(f, l1, l2) {
  if (l1) {
    if (l2) {
      var r = Curry._2(f, l1.hd, l2.hd);
      return {
              hd: r,
              tl: map2(f, l1.tl, l2.tl)
            };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.map2",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "List.map2",
        Error: new Error()
      };
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        _accu = {
          hd: Curry._2(f, l1$1.hd, l2$1.hd),
          tl: accu
        };
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    if (l2$1) {
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    return accu;
  };
}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        Curry._2(f, l1.hd, l2.hd);
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.iter2",
            Error: new Error()
          };
    }
    if (!l2) {
      return ;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.iter2",
          Error: new Error()
        };
  };
}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2.tl;
        _l1 = l1.tl;
        _accu = Curry._3(f, accu, l1.hd, l2.hd);
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    if (l2) {
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    return accu;
  };
}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return Curry._3(f, l1.hd, l2.hd, fold_right2(f, l1.tl, l2.tl, accu));
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  if (l2) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  return accu;
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._1(p, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(p, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (!Curry._2(p, l1.hd, l2.hd)) {
          return false;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.for_all2",
            Error: new Error()
          };
    }
    if (!l2) {
      return true;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.for_all2",
          Error: new Error()
        };
  };
}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1.hd, l2.hd)) {
          return true;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.exists2",
            Error: new Error()
          };
    }
    if (!l2) {
      return false;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.exists2",
          Error: new Error()
        };
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.equal(param.hd, x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function memq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (Caml_obj.equal(match[0], x)) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function assoc_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (Caml_obj.equal(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  };
}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (match[0] === x) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function assq_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (match[0] === x) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  };
}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.equal(param.hd[0], x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd[0] === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function remove_assoc(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (Caml_obj.equal(pair[0], x)) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assoc(x, l)
          };
  }
}

function remove_assq(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (pair[0] === x) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assq(x, l)
          };
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param.hd;
      if (Curry._1(p, x)) {
        return x;
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_opt(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var x = param.hd;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _param = param.tl;
    continue ;
  };
}

function find_all(p) {
  return function (param) {
    var _accu = /* [] */0;
    var _param = param;
    while(true) {
      var param$1 = _param;
      var accu = _accu;
      if (!param$1) {
        return rev_append(accu, /* [] */0);
      }
      var l = param$1.tl;
      var x = param$1.hd;
      if (Curry._1(p, x)) {
        _param = l;
        _accu = {
          hd: x,
          tl: accu
        };
        continue ;
      }
      _param = l;
      continue ;
    };
  };
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (!param) {
      return [
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
    var l$1 = param.tl;
    var x = param.hd;
    if (Curry._1(p, x)) {
      _param = l$1;
      _yes = {
        hd: x,
        tl: yes
      };
      continue ;
    }
    _param = l$1;
    _no = {
      hd: x,
      tl: no
    };
    continue ;
  };
}

function split(param) {
  if (!param) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var match = param.hd;
  var match$1 = split(param.tl);
  return [
          {
            hd: match[0],
            tl: match$1[0]
          },
          {
            hd: match[1],
            tl: match$1[1]
          }
        ];
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return {
              hd: [
                l1.hd,
                l2.hd
              ],
              tl: combine(l1.tl, l2.tl)
            };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.combine",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "List.combine",
        Error: new Error()
      };
}

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  var h2 = l2.hd;
  var h1 = l1.hd;
  if (Curry._2(cmp, h1, h2) <= 0) {
    return {
            hd: h1,
            tl: merge(cmp, l1.tl, l2)
          };
  } else {
    return {
            hd: h2,
            tl: merge(cmp, l1, l2.tl)
          };
  }
}

function chop(_k, _l) {
  while(true) {
    var l = _l;
    var k = _k;
    if (k === 0) {
      return l;
    }
    if (l) {
      _l = l.tl;
      _k = k - 1 | 0;
      continue ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "list.ml",
            262,
            11
          ],
          Error: new Error()
        };
  };
}

function stable_sort(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            if (Curry._2(cmp, x1, x2) <= 0) {
              if (Curry._2(cmp, x2, x3) <= 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              } else if (Curry._2(cmp, x1, x3) <= 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            } else if (Curry._2(cmp, x1, x3) <= 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            } else if (Curry._2(cmp, x2, x3) <= 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        if (Curry._2(cmp, x1$1, x2$1) <= 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var h2 = l2$1.hd;
      var h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2$1.tl;
      continue ;
    };
  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            if (Curry._2(cmp, x1, x2) > 0) {
              if (Curry._2(cmp, x2, x3) > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              } else if (Curry._2(cmp, x1, x3) > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            } else if (Curry._2(cmp, x1, x3) > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            } else if (Curry._2(cmp, x2, x3) > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        if (Curry._2(cmp, x1$1, x2$1) > 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var h2 = l2$1.hd;
      var h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) <= 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2$1.tl;
      continue ;
    };
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function sort_uniq(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = Curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = Curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return {
                        hd: x2,
                        tl: /* [] */0
                      };
              } else if (c$1 < 0) {
                return {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
            }
            if (c < 0) {
              var c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
              if (c$2 < 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              }
              var c$3 = Curry._2(cmp, x1, x3);
              if (c$3 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              } else if (c$3 < 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            }
            var c$4 = Curry._2(cmp, x1, x3);
            if (c$4 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            }
            if (c$4 < 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            }
            var c$5 = Curry._2(cmp, x2, x3);
            if (c$5 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            } else if (c$5 < 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return {
                  hd: x1$1,
                  tl: /* [] */0
                };
        } else if (c$6 < 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var t2 = l2$1.tl;
      var h2 = l2$1.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c$7 = Curry._2(cmp, h1, h2);
      if (c$7 === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c$7 > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    };
  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = Curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = Curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return {
                        hd: x2,
                        tl: /* [] */0
                      };
              } else if (c$1 > 0) {
                return {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
            }
            if (c > 0) {
              var c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
              if (c$2 > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              }
              var c$3 = Curry._2(cmp, x1, x3);
              if (c$3 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              } else if (c$3 > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            }
            var c$4 = Curry._2(cmp, x1, x3);
            if (c$4 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            }
            if (c$4 > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            }
            var c$5 = Curry._2(cmp, x2, x3);
            if (c$5 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            } else if (c$5 > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return {
                  hd: x1$1,
                  tl: /* [] */0
                };
        } else if (c$6 > 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var t2 = l2$1.tl;
      var h2 = l2$1.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c$7 = Curry._2(cmp, h1, h2);
      if (c$7 === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c$7 < 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    };
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function compare_lengths(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function compare_length_with(_l, _n) {
  while(true) {
    var n = _n;
    var l = _l;
    if (!l) {
      if (n === 0) {
        return 0;
      } else if (n > 0) {
        return -1;
      } else {
        return 1;
      }
    }
    if (n <= 0) {
      return 1;
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue ;
  };
}

var append = Pervasives.$at;

var concat = flatten;

var filter = find_all;

var sort = stable_sort;

var fast_sort = stable_sort;

exports.length = length;
exports.compare_lengths = compare_lengths;
exports.compare_length_with = compare_length_with;
exports.cons = cons;
exports.hd = hd;
exports.tl = tl;
exports.nth = nth;
exports.nth_opt = nth_opt;
exports.rev = rev;
exports.init = init;
exports.append = append;
exports.rev_append = rev_append;
exports.concat = concat;
exports.flatten = flatten;
exports.iter = iter;
exports.iteri = iteri;
exports.map = map;
exports.mapi = mapi$1;
exports.rev_map = rev_map;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.iter2 = iter2;
exports.map2 = map2;
exports.rev_map2 = rev_map2;
exports.fold_left2 = fold_left2;
exports.fold_right2 = fold_right2;
exports.for_all = for_all;
exports.exists = exists;
exports.for_all2 = for_all2;
exports.exists2 = exists2;
exports.mem = mem;
exports.memq = memq;
exports.find = find;
exports.find_opt = find_opt;
exports.filter = filter;
exports.find_all = find_all;
exports.partition = partition;
exports.assoc = assoc;
exports.assoc_opt = assoc_opt;
exports.assq = assq;
exports.assq_opt = assq_opt;
exports.mem_assoc = mem_assoc;
exports.mem_assq = mem_assq;
exports.remove_assoc = remove_assoc;
exports.remove_assq = remove_assq;
exports.split = split;
exports.combine = combine;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.fast_sort = fast_sort;
exports.sort_uniq = sort_uniq;
exports.merge = merge;
/* No side effect */

},{"./caml_obj.js":32,"./caml_option.js":33,"./curry.js":37,"./pervasives.js":44}],44:[function(require,module,exports){
'use strict';

var Curry = require("./curry.js");
var Caml_sys = require("./caml_sys.js");
var Caml_format = require("./caml_format.js");
var Caml_string = require("./caml_string.js");
var Caml_exceptions = require("./caml_exceptions.js");
var Caml_js_exceptions = require("./caml_js_exceptions.js");

function failwith(s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: s,
        Error: new Error()
      };
}

function invalid_arg(s) {
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: s,
        Error: new Error()
      };
}

var Exit = /* @__PURE__ */Caml_exceptions.create("Pervasives.Exit");

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */0;
    } else if (x !== 0) {
      return /* FP_subnormal */1;
    } else {
      return /* FP_zero */2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */4;
  } else {
    return /* FP_infinite */3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "char_of_int",
          Error: new Error()
        };
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "bool_of_string",
            Error: new Error()
          };
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      return ;
  }
}

function int_of_string_opt(s) {
  try {
    return Caml_format.int_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return s + ".";
    }
    var match = Caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = i + 1 | 0;
      continue ;
    }
    if (match !== 45) {
      return s;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return Caml_format.float_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function $at(l1, l2) {
  if (l1) {
    return {
            hd: l1.hd,
            tl: $at(l1.tl, l2)
          };
  } else {
    return l2;
  }
}

function print_newline(param) {
  console.log("");
}

function prerr_newline(param) {
  console.error("");
}

function print_int(i) {
  console.log(String(i));
}

function print_float(i) {
  console.log(valid_float_lexem(Caml_format.format_float("%.12g", i)));
}

function print_string(prim) {
  console.log(prim);
}

var exit_function = {
  contents: (function (prim) {
      
    })
};

function at_exit(f) {
  var g = exit_function.contents;
  exit_function.contents = (function (param) {
      Curry._1(f, undefined);
      Curry._1(g, undefined);
    });
}

function exit(retcode) {
  Curry._1(exit_function.contents, undefined);
  return Caml_sys.sys_exit(retcode);
}

var max_int = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var max_float = 1.79769313486231571e+308;

var min_float = 2.22507385850720138e-308;

var epsilon_float = 2.22044604925031308e-16;

exports.invalid_arg = invalid_arg;
exports.failwith = failwith;
exports.Exit = Exit;
exports.abs = abs;
exports.max_int = max_int;
exports.min_int = min_int;
exports.lnot = lnot;
exports.infinity = infinity;
exports.neg_infinity = neg_infinity;
exports.max_float = max_float;
exports.min_float = min_float;
exports.epsilon_float = epsilon_float;
exports.classify_float = classify_float;
exports.char_of_int = char_of_int;
exports.string_of_bool = string_of_bool;
exports.bool_of_string = bool_of_string;
exports.bool_of_string_opt = bool_of_string_opt;
exports.int_of_string_opt = int_of_string_opt;
exports.string_of_float = string_of_float;
exports.float_of_string_opt = float_of_string_opt;
exports.$at = $at;
exports.print_string = print_string;
exports.print_int = print_int;
exports.print_float = print_float;
exports.print_newline = print_newline;
exports.prerr_newline = prerr_newline;
exports.exit = exit;
exports.at_exit = at_exit;
exports.valid_float_lexem = valid_float_lexem;
/* No side effect */

},{"./caml_exceptions.js":28,"./caml_format.js":29,"./caml_js_exceptions.js":31,"./caml_string.js":35,"./caml_sys.js":36,"./curry.js":37}],45:[function(require,module,exports){
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_math = require("rescript/lib/js/js_math.js");
var Tea_app = require("rescript-tea/src/tea_app.bs.js");
var Tea_cmd = require("rescript-tea/src/tea_cmd.bs.js");
var Tea_sub = require("rescript-tea/src/tea_sub.bs.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Tea_html = require("rescript-tea/src/tea_html.bs.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function init(param) {
  return {
          state: {
            hd: {
              hd: [
                "left_upper",
                0
              ],
              tl: {
                hd: [
                  "center_upper",
                  0
                ],
                tl: {
                  hd: [
                    "right_upper",
                    0
                  ],
                  tl: /* [] */0
                }
              }
            },
            tl: {
              hd: {
                hd: [
                  "left_middle",
                  0
                ],
                tl: {
                  hd: [
                    "center_middle",
                    0
                  ],
                  tl: {
                    hd: [
                      "right_middle",
                      0
                    ],
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  hd: [
                    "left_lower",
                    0
                  ],
                  tl: {
                    hd: [
                      "center_lower",
                      0
                    ],
                    tl: {
                      hd: [
                        "right_lower",
                        0
                      ],
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          },
          move: 1,
          winnerCoords: []
        };
}

var toCheck = [
  [
    0,
    1,
    2
  ],
  [
    3,
    4,
    5
  ],
  [
    6,
    7,
    8
  ],
  [
    0,
    3,
    6
  ],
  [
    1,
    4,
    7
  ],
  [
    2,
    5,
    8
  ],
  [
    2,
    4,
    6
  ],
  [
    0,
    4,
    8
  ]
];

var coords = [
  [
    [
      0,
      0
    ],
    [
      0,
      1
    ],
    [
      0,
      2
    ]
  ],
  [
    [
      1,
      0
    ],
    [
      1,
      1
    ],
    [
      1,
      2
    ]
  ],
  [
    [
      2,
      0
    ],
    [
      2,
      1
    ],
    [
      2,
      2
    ]
  ],
  [
    [
      0,
      0
    ],
    [
      1,
      0
    ],
    [
      2,
      0
    ]
  ],
  [
    [
      0,
      1
    ],
    [
      1,
      1
    ],
    [
      2,
      1
    ]
  ],
  [
    [
      0,
      2
    ],
    [
      1,
      2
    ],
    [
      2,
      2
    ]
  ],
  [
    [
      0,
      2
    ],
    [
      1,
      1
    ],
    [
      2,
      0
    ]
  ],
  [
    [
      0,
      0
    ],
    [
      1,
      1
    ],
    [
      2,
      2
    ]
  ]
];

function freePos(s) {
  var fp = [];
  Belt_List.forEachWithIndex(s, (function (i, x) {
          Belt_List.forEachWithIndex(x, (function (j, y) {
                  if (y[1] === 0) {
                    Js_array.push([
                          i,
                          j
                        ], fp);
                    return ;
                  }
                  
                }));
        }));
  return fp;
}

function areSame(r) {
  var a = r[0];
  var b = r[1];
  var c = r[2];
  if (a === b && b === c && a === c) {
    return a > 0;
  } else {
    return false;
  }
}

function check(m) {
  var s = m.state;
  var row = [];
  Belt_List.forEachWithIndex(s, (function (param, x) {
          Belt_List.forEachWithIndex(x, (function (param, y) {
                  Js_array.push(y[1], row);
                }));
        }));
  var a = Belt_Array.map(toCheck, (function (x) {
          var e1 = x[0];
          var e2 = x[1];
          var e3 = x[2];
          return areSame([
                      row[e1],
                      row[e2],
                      row[e3]
                    ]);
        }));
  var opt = Belt_Array.getIndexBy(a, (function (x) {
          return x;
        }));
  var ind = Belt_Option.getWithDefault(opt, -1);
  if (ind >= 0) {
    return Belt_Array.get(coords, ind);
  }
  
}

function nextCoords(fp) {
  var l = fp.length;
  if (l === 0) {
    return ;
  }
  var r = Js_math.random_int(0, l);
  return Belt_Array.get(fp, r);
}

function nextMove(m) {
  if (m.move === 1) {
    return 2;
  } else {
    return 1;
  }
}

function isTerminal(m) {
  var s = m.state;
  var b = Belt_List.reduce(s, true, (function (x, y) {
          var rv = Belt_List.reduce(y, true, (function (p, q) {
                  if (p) {
                    return q[1] !== 0;
                  } else {
                    return false;
                  }
                }));
          if (x) {
            return rv;
          } else {
            return false;
          }
        }));
  if (m.winnerCoords.length !== 0) {
    return true;
  } else {
    return b;
  }
}

function utility(m) {
  if (m.winnerCoords.length === 0) {
    return 0;
  }
  var match = m.winnerCoords[0];
  var row = Belt_Option.getWithDefault(Belt_List.get(m.state, match[0]), /* [] */0);
  var match$1 = Belt_Option.getWithDefault(Belt_List.get(row, match[1]), [
        "",
        0
      ]);
  if (match$1[1] === 1) {
    return 1;
  } else {
    return -1;
  }
}

function freePosToState(pos, s, value) {
  var q = pos[1];
  var p = pos[0];
  return Belt_List.mapWithIndex(s, (function (i, x) {
                return Belt_List.mapWithIndex(x, (function (j, y) {
                              var c = y[0];
                              if (i === p && q === j) {
                                return [
                                        c,
                                        value
                                      ];
                              } else {
                                return [
                                        c,
                                        y[1]
                                      ];
                              }
                            }));
              }));
}

function minValue(m) {
  if (isTerminal(m)) {
    return [
            utility(m),
            undefined
          ];
  }
  var fp = freePos(m.state);
  var models = Belt_Array.map(fp, (function (x) {
          var nm = nextMove(m);
          var s = freePosToState(x, m.state, nm);
          var newModel_winnerCoords = m.winnerCoords;
          var newModel = {
            state: s,
            move: nm,
            winnerCoords: newModel_winnerCoords
          };
          var opt = check(newModel);
          var sameCoords = Belt_Option.getWithDefault(opt, []);
          var model = {
            state: s,
            move: nm,
            winnerCoords: sameCoords
          };
          var match = maxValue(model);
          return [
                  match[0],
                  x
                ];
        }));
  var match = Belt_Array.reduce(models, [
        1000,
        undefined
      ], (function (a, b) {
          var v2 = b[0];
          var v1 = a[0];
          if (v1 < v2) {
            return [
                    v1,
                    a[1]
                  ];
          } else {
            return [
                    v2,
                    b[1]
                  ];
          }
        }));
  return [
          match[0],
          match[1]
        ];
}

function maxValue(m) {
  if (isTerminal(m)) {
    return [
            utility(m),
            undefined
          ];
  }
  var fp = freePos(m.state);
  var models = Belt_Array.map(fp, (function (x) {
          var nm = nextMove(m);
          var s = freePosToState(x, m.state, nm);
          var newModel_winnerCoords = m.winnerCoords;
          var newModel = {
            state: s,
            move: nm,
            winnerCoords: newModel_winnerCoords
          };
          var opt = check(newModel);
          var sameCoords = Belt_Option.getWithDefault(opt, []);
          var model = {
            state: s,
            move: nm,
            winnerCoords: sameCoords
          };
          var match = minValue(model);
          return [
                  match[0],
                  x
                ];
        }));
  var match = Belt_Array.reduce(models, [
        -1000,
        undefined
      ], (function (a, b) {
          var v2 = b[0];
          var v1 = a[0];
          if (v1 > v2) {
            return [
                    v1,
                    a[1]
                  ];
          } else {
            return [
                    v2,
                    b[1]
                  ];
          }
        }));
  return [
          match[0],
          match[1]
        ];
}

function minimaxSearch(m) {
  var match = maxValue(m);
  var move = match[1];
  console.log(move);
  return Belt_Option.getWithDefault(move, [
              -1,
              -1
            ]);
}

function update(model, msg) {
  var winnerCoords = model.winnerCoords;
  if (winnerCoords.length !== 0) {
    return [
            model,
            Tea_cmd.none
          ];
  }
  var j = msg._1;
  var i = msg._0;
  var s = Belt_List.mapWithIndex(model.state, (function (n, x) {
          return Belt_List.mapWithIndex(x, (function (m, y) {
                        var a = y[0];
                        var p = nextMove(model);
                        if (n === i && m === j) {
                          return [
                                  a,
                                  p
                                ];
                        } else {
                          return [
                                  a,
                                  y[1]
                                ];
                        }
                      }));
        }));
  var nm = nextMove(model);
  var newModel_winnerCoords = model.winnerCoords;
  var newModel = {
    state: s,
    move: nm,
    winnerCoords: newModel_winnerCoords
  };
  var opt = check(newModel);
  var sameCoords = Belt_Option.getWithDefault(opt, []);
  if (nm === 1) {
    return [
            {
              state: s,
              move: nm,
              winnerCoords: sameCoords
            },
            Tea_cmd.none
          ];
  }
  if (nm !== 2) {
    return [
            {
              state: s,
              move: nm,
              winnerCoords: sameCoords
            },
            Tea_cmd.none
          ];
  }
  var match = minimaxSearch(newModel);
  var y = match[1];
  var x = match[0];
  if (Caml_obj.equal([
          x,
          y
        ], [
          -1,
          -1
        ])) {
    return [
            {
              state: s,
              move: nm,
              winnerCoords: sameCoords
            },
            Tea_cmd.none
          ];
  } else {
    return [
            {
              state: s,
              move: nm,
              winnerCoords: sameCoords
            },
            Tea_cmd.msg(/* Coords */{
                  _0: x,
                  _1: y
                })
          ];
  }
}

function viewButton(title, msg) {
  return Tea_html.button(undefined, undefined, {
              hd: Tea_html.Events.onClick(msg),
              tl: /* [] */0
            }, {
              hd: Tea_html.text(title),
              tl: /* [] */0
            });
}

function subscriptions(param) {
  return Tea_sub.none;
}

function cellStyle(i, j, m) {
  var wc = m.winnerCoords;
  if (Js_array.findIndex((function (x) {
            return Caml_obj.equal(x, [
                        i,
                        j
                      ]);
          }), wc) >= 0) {
    return {
            hd: Tea_html.Attributes.classList({
                  hd: [
                    "circle",
                    true
                  ],
                  tl: {
                    hd: [
                      "winner",
                      true
                    ],
                    tl: /* [] */0
                  }
                }),
            tl: /* [] */0
          };
  } else {
    return {
            hd: Tea_html.Attributes.$$class("circle"),
            tl: /* [] */0
          };
  }
}

function view(model) {
  return Tea_html.div(undefined, undefined, {
              hd: Tea_html.Attributes.$$class("wrapper"),
              tl: /* [] */0
            }, {
              hd: Tea_html.div(undefined, undefined, {
                    hd: Tea_html.Attributes.$$class("field"),
                    tl: /* [] */0
                  }, Belt_List.mapWithIndex(model.state, (function (i, x) {
                          return Tea_html.div(undefined, undefined, {
                                      hd: Tea_html.Attributes.$$class("row"),
                                      tl: /* [] */0
                                    }, Belt_List.mapWithIndex(x, (function (j, y) {
                                            var v = y[1];
                                            var t = v === 0 ? "" : (
                                                v === 1 ? "x" : "o"
                                              );
                                            return Tea_html.div(undefined, undefined, {
                                                        hd: Tea_html.Attributes.$$class(y[0]),
                                                        tl: {
                                                          hd: Tea_html.Events.onClick(/* Coords */{
                                                                _0: i,
                                                                _1: j
                                                              }),
                                                          tl: /* [] */0
                                                        }
                                                      }, {
                                                        hd: Tea_html.div(undefined, undefined, cellStyle(i, j, model), {
                                                              hd: Tea_html.text(t),
                                                              tl: /* [] */0
                                                            }),
                                                        tl: /* [] */0
                                                      });
                                          })));
                        }))),
              tl: /* [] */0
            });
}

function partial_arg_init(param) {
  return [
          init(undefined),
          Tea_cmd.none
        ];
}

var partial_arg = {
  init: partial_arg_init,
  update: update,
  view: view,
  subscriptions: subscriptions
};

function main(param, param$1) {
  return Tea_app.standardProgram(partial_arg, param, param$1);
}

exports.init = init;
exports.toCheck = toCheck;
exports.coords = coords;
exports.freePos = freePos;
exports.areSame = areSame;
exports.check = check;
exports.nextCoords = nextCoords;
exports.nextMove = nextMove;
exports.isTerminal = isTerminal;
exports.utility = utility;
exports.freePosToState = freePosToState;
exports.minValue = minValue;
exports.maxValue = maxValue;
exports.minimaxSearch = minimaxSearch;
exports.update = update;
exports.viewButton = viewButton;
exports.subscriptions = subscriptions;
exports.cellStyle = cellStyle;
exports.view = view;
exports.main = main;
/* Tea_app Not a pure module */

},{"rescript-tea/src/tea_app.bs.js":1,"rescript-tea/src/tea_cmd.bs.js":2,"rescript-tea/src/tea_html.bs.js":3,"rescript-tea/src/tea_sub.bs.js":6,"rescript/lib/js/belt_Array.js":19,"rescript/lib/js/belt_List.js":20,"rescript/lib/js/belt_Option.js":22,"rescript/lib/js/caml_obj.js":32,"rescript/lib/js/js_array.js":38,"rescript/lib/js/js_math.js":42}],46:[function(require,module,exports){
var app = require("./HelloWorld.bs.js").main(document.getElementById("content"));

},{"./HelloWorld.bs.js":45}],47:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[46]);
